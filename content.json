[{"title":"Thinking in Java 第十五章 泛型(一)","date":"2018-01-23T02:04:08.000Z","path":"2018/01/23/Thinking-in-Java-第十五章-泛型(一)/","text":"15.1 与C++的比较 了解C++模板的某些方面，有助于理解泛型的基础 了解java中泛型的局限性，也就是他的边界。只有了解了边界所在才能够称为程序高手（原因是不必在死胡同打转） 15.2 简单泛型泛型出现的原因之一就是为了创造容器类，泛型出现之前都是利用Object来存储不同的对象，当使用的时候在进行强制转换，这种做法是不安全的，无法保证强制转换的时候不出错。通常情况下，我们的容器中只存一种元素，泛型的主要目的之一就是指定容器要持有什么类型的对象，并且由编译器来保证类型的正确性。 当使用的时候我们倾向于先不指定什么类型，然后稍后再决定使用什么类型，要达到这个目的，可以适用类型参数：需要使用的类型参数放到类的后边用尖括号括起来，再类的内部定义的时候我们可以用类型参数T来替代，当实例化这个类的时候，在用实际的类型来替代。代码如下： 123456789101112public class Holder3&lt;T&gt; &#123; private T a; public Holder3(T a)&#123;this.a = a ;&#125; public void set(T a )&#123; this.a = a ;&#125; public T get()&#123;return this .a ;&#125; public static void main(String[] args) &#123; Holder3&lt;Automobile&gt; holder3 = new Holder3&lt;Automobile&gt;(new Automobile()); holder3.set( new Automobile()); Automobile automobile = holder3 .get(); &#125; static class Automobile&#123; &#125;&#125; 一个元组类库 元组：元组就是将一组对象直接打包存储进一个单一对象，这个容器只允许存，不允许放入新的对象（这个概念也成为数据传送对象或信使）。可以解决想在一个return语句中返回多个对象的问题。泛型可以让我们很容易的创建元组下面是利用泛型实现元组的一个实例： 123456789public class TwoTuple&lt;A,B&gt; &#123; public final A first ; public final B second ; public TwoTuple(A first,B second)&#123; this.first = first ; this.second = second ; &#125; public String toString() &#123; return first +\",\" +second ;&#125;&#125; 一个堆栈类 不用LinkedList，自己实现的内部链式存储机制： 1234567891011121314151617181920212223242526272829public class LinkedStack&lt;T&gt; &#123; private static class Node&lt;U&gt; &#123; U item; Node&lt;U&gt; next; Node() &#123; item = null; next = null; &#125; Node(U item, Node&lt;U&gt; next) &#123; this.item = item; this.next = next; &#125; boolean end() &#123; return item == null &amp;&amp; next == null; &#125; &#125; private Node&lt;T&gt; top = new Node&lt;T&gt;(); public void push(T item) &#123; top = new Node&lt;T&gt;(item, top); &#125; public T pop() &#123; T result = top.item; if (!top.end()) &#123; top = top.next; &#125; return result; &#125;&#125; 另一个例子RandomList：假设我们需要一个持有特定类型对象的列表，每次调用其上的select()方法时，它可以随机地选取一个元素： 12345678910class RandomList&lt;T&gt; &#123; private ArrayList&lt;T&gt; storage = new ArrayList&lt;T&gt;(); private Random rand = new Random(47); public void add(T t) &#123; storage.add(t); &#125; public T select() &#123; return storage.get(rand.nextInt()storage.size()); &#125;&#125; 15.3 泛型接口接口使用泛型和类使用泛型没有什么不同。下面展示一个泛型接口的应用：生成器 1234567891011121314151617181920public interface Generator&lt;T&gt; &#123; T next();&#125;public class Fibonacci implements Generator&lt;Integer&gt;&#123; private int count = 0; private int fib(int n )&#123; if (n &lt; 2)&#123;return 1;&#125; return fib(n -2)+fib(n -1); &#125; @Override public Integer next() &#123; return fib(count ++); &#125; public static void main(String[] args) &#123; Fibonacci fibonacci = new Fibonacci(); for(int i = 0;i &lt;100;i ++)&#123; System. out.print(fibonacci .next()+\" \" ); &#125; &#125;&#125; 泛型中，基本类型无法作为类型参数。不过Java SE5具备了自动打包和自动拆包的功能，可以很方便地在基本类型和其相应的包装器类型之间进行转换 15.4 泛型方法 可以在类中包含参数化方法，而这个方法所在的类可以是泛型类，也可以不是泛型类。也就是说，是否拥有泛型方法，与其所在的类是否是泛型没有关系。 指导原则：如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法， 对于一个static方法而言，无法访问泛型类的类型参数，所以如果static方法需要使用泛型能力，就必须使其成为泛型方法。 要定义泛型方法，只需将泛型参数列表置于返回值之前： 123public &lt;T&gt; void f(T x) &#123; System.out.println(x.getClass().getName());&#125; 如果调用f()时传入的是基本类型，自动打包机制就会介入其中，将基本类型的值包装为对应的对象。 杠杆利用类型参数推断当使用泛型类时，必须在创建对象时指定类型参数的值，而使用泛型方法的时候，通常不必指定参数类型。因为编译器会为我们找出具体的类型，这称为类型参数推断 1234567891011121314151617181920212223242526public class New &#123; public static &lt;K,V&gt; Map&lt;K,V&gt; map() &#123; return new HashMap&lt;K,V&gt;(); &#125; public static &lt;T&gt; List&lt;T&gt; list() &#123; return new ArrayList&lt;T&gt;(); &#125; public static &lt;T&gt; LinkedList&lt;T&gt; lList() &#123; return new LinkedList&lt;T&gt;(); &#125; public static &lt;T&gt; Set&lt;T&gt; set() &#123; return new HashSet&lt;T&gt;(); &#125; public static &lt;T&gt; Queue&lt;T&gt; queue() &#123; return new LinkedList&lt;T&gt;(); &#125; // Examples: public static void main(String[] args) &#123; //根据被赋值的类型推断含税的类型参数 Map&lt;String, List&lt;String&gt;&gt; sls = New.map(); List&lt;String&gt; ls = New.list(); LinkedList&lt;String&gt; lls = New.lList(); Set&lt;String&gt; ss = New.set(); Queue&lt;String&gt; qs = New.queue(); &#125;&#125; ///:~ 显式的类型说明在泛型方法中，可以显式地指明类型，不过这种语法很少使用，要显式地指明类型，必须要在点操作符与方法名之间插入尖括号，然后把类型置于尖括号内， 123456public class ExplicitTypeSpecification &#123; static void f(Map&lt;Person, List&lt;Pet&gt;&gt; petPeople) &#123;&#125; public static void main(String[] args) &#123; f(New.&lt;Person, List&lt;Pet&gt;&gt;map()); &#125;&#125; ///:~ 可变参数与泛型方法泛型方法与可变参数列表可以很好的共存： 123456789101112131415161718192021public class GenericVarargs &#123; //泛型方法 &amp; 可变参数列表 public static &lt;T&gt; List&lt;T&gt; makeList(T... args) &#123; List&lt;T&gt; result = new ArrayList&lt;T&gt;(); for(T item : args) result.add(item); return result; &#125; public static void main(String[] args) &#123; List&lt;String&gt; ls = makeList(\"A\"); System.out.println(ls); ls = makeList(\"A\", \"B\", \"C\"); System.out.println(ls); ls = makeList(\"ABCDEFFHIJKLMNOPQRSTUVWXYZ\".split(\"\")); System.out.println(ls); &#125;&#125; /* Output:[A][A, B, C][, A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z]*///:~ 用于Gnerator的泛型方法利用生成器，可以很方便地填充一个Collection，而泛型化这种操作是具有实际操作意义的 12345678910111213141516171819202122232425public class Generators &#123; public static &lt;T&gt; Collection&lt;T&gt; fill(Collection&lt;T&gt; coll, Generator&lt;T&gt; gen, int n) &#123; for(int i = 0; i &lt; n; i++) coll.add(gen.next()); return coll; &#125; public static void main(String[] args) &#123; // 调用fill()方法时，由ArrayList&lt;Coffee&gt;()，推断出类型参数T为Coffee类型 Collection&lt;Coffee&gt; coffee = fill( new ArrayList&lt;Coffee&gt;(), new CoffeeGenerator(), 4); for(Coffee c : coffee) System.out.println(c); Collection&lt;Integer&gt; fnumbers = fill( new ArrayList&lt;Integer&gt;(), new Fibonacci(), 12); for(int i : fnumbers) System.out.print(i + \", \"); &#125;&#125; /* Output:Americano 0Latte 1Americano 2Mocha 31, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144,*///:~ 一个通用的Generator12345678910111213141516public class BasicGenerator&lt;T&gt; implements Generator&lt;T&gt; &#123; private Class&lt;T&gt; type; public BasicGenerator(Class&lt;T&gt; type)&#123; this.type = type; &#125; public T next() &#123; try &#123; // Assumes type is a public class: return type.newInstance(); &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; &#125; // Produce a Default generator given a type token: public static &lt;T&gt; Generator&lt;T&gt; create(Class&lt;T&gt; type) &#123; return new BasicGenerator&lt;T&gt;(type); &#125;&#125; ///:~ 使用该BasicGenerator类的类必须具备以下两个特点： 它必须声明为public，因为BasicGenerator与处理的类在不同的包里 必须具有默认的构造器（无参构造器）。要创建这样的BasicGenerator对象，只需要调用create()方法执行BasicGenerator.create(MyType.class)，而不必执行麻烦的new BasicGenerator((MyType))(MyType.class) 简化元组的使用利用参数推断，和static方法，重新实现元组工具 12345678public class TwoTuple&lt;A,B&gt; &#123; public final A first; public final B second; public TwoTuple(A a, B b) &#123; first = a; second = b; &#125; public String toString() &#123; return \"(\" + first + \", \" + second + \")\"; &#125;&#125; ///:~ 1234567891011121314151617public class Tuple &#123; public static &lt;A,B&gt; TwoTuple&lt;A,B&gt; tuple(A a, B b) &#123; return new TwoTuple&lt;A,B&gt;(a, b); &#125; public static &lt;A,B,C&gt; ThreeTuple&lt;A,B,C&gt; tuple(A a, B b, C c) &#123; return new ThreeTuple&lt;A,B,C&gt;(a, b, c); &#125; public static &lt;A,B,C,D&gt; FourTuple&lt;A,B,C,D&gt; tuple(A a, B b, C c, D d) &#123; return new FourTuple&lt;A,B,C,D&gt;(a, b, c, d); &#125; public static &lt;A,B,C,D,E&gt; FiveTuple&lt;A,B,C,D,E&gt; tuple(A a, B b, C c, D d, E e) &#123; return new FiveTuple&lt;A,B,C,D,E&gt;(a, b, c, d, e); &#125;&#125; ///:~ 123456789101112131415161718192021222324252627282930313233343536public class TupleTest2 &#123; static TwoTuple&lt;String,Integer&gt; f() &#123; return tuple(\"hi\", 47); &#125; static TwoTuple f2() &#123; return tuple(\"hi\", 47); &#125; static ThreeTuple&lt;Amphibian,String,Integer&gt; g() &#123; return tuple(new Amphibian(), \"hi\", 47); &#125; static FourTuple&lt;Vehicle,Amphibian,String,Integer&gt; h() &#123; return tuple(new Vehicle(), new Amphibian(), \"hi\", 47); &#125; static FiveTuple&lt;Vehicle,Amphibian,String,Integer,Double&gt; k() &#123; return tuple(new Vehicle(), new Amphibian(), \"hi\", 47, 11.1); &#125; public static void main(String[] args) &#123; // f()返回的是一个参数化的TwoTuple对象 TwoTuple&lt;String,Integer&gt; ttsi = f(); System.out.println(ttsi); // f2()返回的是一个非参数化的TwoTuple对象。 //在某种意义上，它被“向上转型”为一个非参数化得TwoTuple对象。 //但是，如果试图将f2()的返回值转型为参数化的TwoTuple，编译器就会发出警告 System.out.println(f2()); System.out.println(g()); System.out.println(h()); System.out.println(k()); &#125;&#125; /* Output: (80% match)(hi, 47)(hi, 47)(Amphibian@7d772e, hi, 47)(Vehicle@757aef, Amphibian@d9f9c3, hi, 47)(Vehicle@1a46e30, Amphibian@3e25a5, hi, 47, 11.1)*///:~ 一个Set实用工具12345678910111213141516171819202122232425public class Sets &#123; public static &lt;T&gt; Set&lt;T&gt; union(Set&lt;T&gt; a, Set&lt;T&gt; b) &#123; //将传入的参数复制一份，然后在新的HashSet对象中操作 Set&lt;T&gt; result = new HashSet&lt;T&gt;(a); result.addAll(b); return result; &#125; public static &lt;T&gt; Set&lt;T&gt; intersection(Set&lt;T&gt; a, Set&lt;T&gt; b) &#123; Set&lt;T&gt; result = new HashSet&lt;T&gt;(a); result.retainAll(b); return result; &#125; // Subtract subset from superset: public static &lt;T&gt; Set&lt;T&gt; difference(Set&lt;T&gt; superset, Set&lt;T&gt; subset) &#123; Set&lt;T&gt; result = new HashSet&lt;T&gt;(superset); result.removeAll(subset); return result; &#125; // Reflexive--everything not in the intersection: public static &lt;T&gt; Set&lt;T&gt; complement(Set&lt;T&gt; a, Set&lt;T&gt; b) &#123; return difference(union(a, b), intersection(a, b)); &#125;&#125; ///:~ 12345678public enum Watercolors &#123; ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW, ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER, BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK&#125; ///:~ 123456789101112131415161718192021222324252627public class WatercolorSets &#123; public static void main(String[] args) &#123; Set&lt;Watercolors&gt; set1 = EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE); Set&lt;Watercolors&gt; set2 = EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER); print(\"set1: \" + set1); print(\"set2: \" + set2); print(\"union(set1, set2): \" + union(set1, set2)); Set&lt;Watercolors&gt; subset = intersection(set1, set2); print(\"intersection(set1, set2): \" + subset); print(\"difference(set1, subset): \" + difference(set1, subset)); print(\"difference(set2, subset): \" + difference(set2, subset)); print(\"complement(set1, set2): \" + complement(set1, set2)); &#125; &#125; /* Output: (Sample)set1: [BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE]set2: [CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER, BURNT_UMBER]union(set1, set2): [SAP_GREEN, ROSE_MADDER, YELLOW_OCHRE, PERMANENT_GREEN, BURNT_UMBER, COBALT_BLUE_HUE, VIOLET, BRILLIANT_RED, RAW_UMBER, ULTRAMARINE, BURNT_SIENNA, CRIMSON, CERULEAN_BLUE_HUE, PHTHALO_BLUE, MAGENTA, VIRIDIAN_HUE]intersection(set1, set2): [ULTRAMARINE, PERMANENT_GREEN, COBALT_BLUE_HUE, PHTHALO_BLUE, CERULEAN_BLUE_HUE, VIRIDIAN_HUE]difference(set1, subset): [ROSE_MADDER, CRIMSON, VIOLET, MAGENTA, BRILLIANT_RED]difference(set2, subset): [RAW_UMBER, SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, BURNT_UMBER]complement(set1, set2): [SAP_GREEN, ROSE_MADDER, YELLOW_OCHRE, BURNT_UMBER, VIOLET, BRILLIANT_RED, RAW_UMBER, BURNT_SIENNA, CRIMSON, MAGENTA]*///:~ EnumSet可以从enum直接创建Set, EnumSet.ranger(StartEnum, EndEnum)返回从StartEnum到EndEnum的所有Enum组成的EnumSet 15.5 匿名内部类泛型还可以用于内部类以及匿名类。下面的示例使用匿名内部类实现了Gneerator接口：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Customer &#123; private static long counter = 1; private final long id = counter++; private Customer() &#123;&#125; public String toString() &#123; return \"Customer \" + id; &#125; // A method to produce Generator objects: public static Generator&lt;Customer&gt; generator() &#123; //匿名内部类实现泛型接口 return new Generator&lt;Customer&gt;() &#123; public Customer next() &#123; return new Customer(); &#125; &#125;; &#125;&#125; class Teller &#123; private static long counter = 1; private final long id = counter++; private Teller() &#123;&#125; public String toString() &#123; return \"Teller \" + id; &#125; // A single Generator object: public static Generator&lt;Teller&gt; generator = ////匿名内部类实现泛型接口 new Generator&lt;Teller&gt;() &#123; public Teller next() &#123; return new Teller(); &#125; &#125;;&#125; public class BankTeller &#123; public static void serve(Teller t, Customer c) &#123; System.out.println(t + \" serves \" + c); &#125; public static void main(String[] args) &#123; Random rand = new Random(47); Queue&lt;Customer&gt; line = new LinkedList&lt;Customer&gt;(); Generators.fill(line, Customer.generator(), 15); List&lt;Teller&gt; tellers = new ArrayList&lt;Teller&gt;(); Generators.fill(tellers, Teller.generator, 4); for(Customer c : line) serve(tellers.get(rand.nextInt(tellers.size())), c); &#125; &#125; /* Output:Teller 3 serves Customer 1Teller 2 serves Customer 2Teller 3 serves Customer 3Teller 1 serves Customer 4Teller 1 serves Customer 5Teller 3 serves Customer 6Teller 1 serves Customer 7Teller 2 serves Customer 8Teller 3 serves Customer 9Teller 3 serves Customer 10Teller 2 serves Customer 11Teller 4 serves Customer 12Teller 2 serves Customer 13Teller 1 serves Customer 14Teller 1 serves Customer 15*///:~ 15.6 构建复杂模型泛型的一个重要好处是简单而安全地创建复杂的模型。例如，我们可以很容易地创建List元组 1234567891011121314public class TupleList&lt;A,B,C,D&gt;extends ArrayList&lt;FourTuple&lt;A,B,C,D&gt;&gt; &#123; public static void main(String[] args) &#123; TupleList&lt;Vehicle, Amphibian, String, Integer&gt; tl = new TupleList&lt;Vehicle, Amphibian, String, Integer&gt;(); tl.add(TupleTest.h()); tl.add(TupleTest.h()); for(FourTuple&lt;Vehicle,Amphibian,String,Integer&gt; i: tl) System.out.println(i); &#125;&#125; /* Output: (75% match)(Vehicle@11b86e7, Amphibian@35ce36, hi, 47)(Vehicle@757aef, Amphibian@d9f9c3, hi, 47)*///:~ 使用泛型类型来构建复杂模型十分简单。即使每个类都作为一个构件块创建，但是其整个还是包含了许多部分 12345678910111213141516171819@startumlclass ArrayListclass Storeclass Aisleclass Shelfclass Productclass Checkoutclass OfficeArrayList &lt;|-- StoreArrayList &lt;|-- AisleArrayList &lt;|-- ShelfArrayList &lt;|-- ProductStore *-- CheckoutStore *-- OfficeShelf *-- ProductAisle *-- ShelfStore *-- Aisle@enduml 15.7 擦除的神秘之处在泛型代码内部，无法获取任何有关泛型参数类型的信息：泛型的Class对象只会保留目标类型的第一边界的类型信息 123456789public class ErasedTypeEquivalence &#123; public static void main(String[] args) &#123; Class c1 = new ArrayList&lt;String&gt;().getClass(); Class c2 = new ArrayList&lt;Integer&gt;().getClass(); System.out.println(c1 == c2); &#125;&#125; /* Output:true*///:~ ArrayList和ArrayList被类型擦除后，其类型都是ArrayList Class.getTypeParameters()将“返回一个TypeVariable对象数组，表示有泛型声明所声明的类型参数T,V…不是实际类型”，你能够发现的只是用作占位符的标识符，这并非有用信息 1234567891011121314151617181920212223242526class Frob &#123;&#125;class Fnorkle &#123;&#125;class Quark&lt;Q&gt; &#123;&#125;class Particle&lt;POSITION,MOMENTUM&gt; &#123;&#125;public class LostInformation &#123; public static void main(String[] args) &#123; List&lt;Frob&gt; list = new ArrayList&lt;Frob&gt;(); Map&lt;Frob,Fnorkle&gt; map = new HashMap&lt;Frob,Fnorkle&gt;(); Quark&lt;Fnorkle&gt; quark = new Quark&lt;Fnorkle&gt;(); Particle&lt;Long,Double&gt; p = new Particle&lt;Long,Double&gt;(); System.out.println(Arrays.toString( list.getClass().getTypeParameters())); System.out.println(Arrays.toString( map.getClass().getTypeParameters())); System.out.println(Arrays.toString( quark.getClass().getTypeParameters())); System.out.println(Arrays.toString( p.getClass().getTypeParameters())); &#125;&#125; /* Output:[E][K, V][Q][POSITION, MOMENTUM]*///:~ 因此，Java的泛型中，你只能知道参数标识符和泛型类边界这两个信息，任何具体的类型信息都将被擦除，你唯一知道的就是你在使用一个对象 C++的方式1234567891011121314151617181920212223//: generics/Templates.cpp#include &lt;iostream&gt;using namespace std;template&lt;class T&gt; class Manipulator &#123; T obj;public: Manipulator(T x) &#123; obj = x; &#125; void manipulate() &#123; obj.f(); &#125;&#125;;class HasF &#123;public: void f() &#123; cout &lt;&lt; \"HasF::f()\" &lt;&lt; endl; &#125;&#125;;int main() &#123; HasF hf; Manipulator&lt;HasF&gt; manipulator(hf); manipulator.manipulate();&#125; /* Output:HasF::f()///:~ C++中，Manipulator类存储了一个类型T的对象，在manipulate()方法中，它在obj上调用方法f()。它怎么知道T中有一个f()方法呢？实际上，在Manipulator被实例化的时候，它检查到HasF拥有一个方法f()。如果情况并非如此，就会得到一个编译期错误，这样类型安全就得到保障。 java的方式123456789101112131415class Manipulator&lt;T&gt; &#123; private T obj; public Manipulator(T x) &#123; obj = x; &#125; // Error: cannot find symbol: method f(): public void manipulate() &#123; obj.f(); &#125;&#125;public class Manipulation &#123; public static void main(String[] args) &#123; HasF hf = new HasF(); Manipulator&lt;HasF&gt; manipulator = new Manipulator&lt;HasF&gt;(hf); manipulator.manipulate(); &#125;&#125; ///:~ 由于有类型擦除，Java编译器无法将manipulate()必须能够在obj上调用f()这一需求映射到HasF拥有f()这一事实上。因此将无法通过编译。 为了解决这个问题，java中可以定义泛型类的边界，以此告诉编译器只能接受遵循这个边界的类型，这里重用了extends关键字 12345class Manipulator2&lt;T extends HasF&gt; &#123; private T obj; public Manipulator2(T x) &#123; obj = x; &#125; public void manipulate() &#123; obj.f(); &#125;&#125; ///:~ 声明了T必须具有类型HasF或者HasF导出的类型 泛型类型参数将擦除到它的第一个边界（它可能会有多个边界）。编译器实际上会把类型参数替换为它的擦除。就像上例所示一样，T擦除到了HasF，就像在类的声明中用HasF替换T一样 什么情况使用泛型？当你希望使用的类型参数比某个具体类型（以及它的所有子类型）更加泛化时——也就是说，当你希望代码能够跨越多个类工作时，使用泛型才有帮助 迁移兼容性为什么要擦除类型？ 在基于擦除的实现中，泛型类型被当做第二类类型进行处理，即不能再某些重要的上下文环境中使用的类型。泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如List这样的类型注解将被擦除为List，而普通的类型变量在未指定边界的情况下将被擦除为Object 为了使Java泛型不仅必须支持向后兼容性，即现有的代码和类文件仍旧合法。并且当某个类库变为泛型时，不会破坏依赖于它的代码和应用程序。 因此，为了实现迁移兼容性，每个类库和应用程序都必须与其他所有部分使用了泛型无关。这样，它们必须不具备探测其他类库是否使用了泛型的能力。因此，某个特定类库使用了泛型的证据必须被擦除。 擦除的问题 擦除的主要理由是：从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入java语言 擦除的代价: 泛型将不能用于显式地引用运行时类型的操作之中，例如转型、instanceof操作和new表达式 边界处的动作泛型最令人困惑的方面源自：可以表示没有任何意义的事物 12345678910111213141516public class ArrayMaker&lt;T&gt; &#123; private Class&lt;T&gt; kind; public ArrayMaker(Class&lt;T&gt; kind) &#123; this.kind = kind; &#125; @SuppressWarnings(\"unchecked\") T[] create(int size) &#123; return (T[])Array.newInstance(kind, size); &#125; public static void main(String[] args) &#123; ArrayMaker&lt;String&gt; stringMaker = new ArrayMaker&lt;String&gt;(String.class); String[] stringArray = stringMaker.create(9); System.out.println(Arrays.toString(stringArray)); &#125;&#125; /* Output:[null, null, null, null, null, null, null, null, null]*///:~ 即使kind被存储为Class，擦除也意味着呗存储为Class，没有任何参数。因此，当你在使用它时，例如在创建数组时，Array.newInstance()实际上并未拥有kind所蕴含的类型信息，因此这不会产生具体的结果，所有必须转型，这将产生一条令你无法满意的警告 如果是创建一个泛型的容器而不是泛型的数组： 1234567public class ListMaker&lt;T&gt; &#123; List&lt;T&gt; create() &#123; return new ArrayList&lt;T&gt;(); &#125; public static void main(String[] args) &#123; ListMaker&lt;String&gt; stringMaker= new ListMaker&lt;String&gt;(); List&lt;String&gt; stringList = stringMaker.create(); &#125;&#125; ///:~ 编译器不会有任何的警告，尽管我们知道在create()内部的new ArrayList中的被移除了–在运行时，这个类的内部没有任何的，因此这看起来毫无意义。但是你如果遵从这种思路，并将表达式改为new ArrayList()，编译器就会给出警告。 12345678910111213141516public class FilledListMaker&lt;T&gt; &#123; List&lt;T&gt; create(T t, int n) &#123; List&lt;T&gt; result = new ArrayList&lt;T&gt;(); for(int i = 0; i &lt; n; i++) result.add(t); return result; &#125; public static void main(String[] args) &#123; FilledListMaker&lt;String&gt; stringMaker = new FilledListMaker&lt;String&gt;(); List&lt;String&gt; list = stringMaker.create(\"Hello\", 4); System.out.println(list); &#125;&#125; /* Output:[Hello, Hello, Hello, Hello]*///:~ 即使编译器无法知道有关create()中的T的任何信息，但是它仍旧可在编译器确保你放置到result中的对象具有T类型，时期适合ArrayLit。因此，即使擦除在方法或类内部移除了有关实际类型的信息，编译器仍旧可以确保在方法或类中使用的类型的内部一致性 擦除在方法体重移除了类型信息，而这些动作将发生在运行时的调用边界：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。 1234567891011public class GenericHolder&lt;T&gt; &#123; private T obj; public void set(T obj) &#123; this.obj = obj; &#125; public T get() &#123; return obj; &#125; public static void main(String[] args) &#123; GenericHolder&lt;String&gt; holder = new GenericHolder&lt;String&gt;(); holder.set(\"Item\"); String s = holder.get(); &#125;&#125; ///:~ javap -c GenericHolder，反编译这个类，得到： ch15.8-1 可以看到set()和get()方法执行时是直接存储和产生值的，而转型是在调用get()的时候接受类型检查的 进入set()的类型进行检查是不需要的，因为这将由编译器执行。而这对从get()返回的值进行转型仍旧是需要的。 在泛型中，所有的动作都发生在边界处–对传递进来的值进行额外的编译期检查，并插入对传递出去的值的转型。 15.8 擦除的补偿由于类型擦除，一下几个操作在在泛型中都将非法 123456789public class Erased&lt;T&gt; &#123; private final int SIZE = 100; public static void f(Object arg) &#123; if(arg instanceof T) &#123;&#125; // Error T var = new T(); // Error T[] array = new T[SIZE]; // Error T[] array = (T)new Object[SIZE]; // Unchecked warning &#125;&#125; ///:~ 创建类型实例无法实现new T()这个问题一方面是因为擦除的原因；另一方面是因为编译器不能验证T具有默认的无参构造函数 解决new T这个问题，可以通过显式的传递你所需要的类型的Class对象，该对象可作为工厂对象 123456789101112131415161718192021222324252627282930class ClassAsFactory&lt;T&gt; &#123; T x; //传递一个工厂对象--Class对象 public ClassAsFactory(Class&lt;T&gt; kind) &#123; try &#123; x = kind.newInstance(); &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125;class Employee &#123;&#125;public class InstantiateGenericType &#123; public static void main(String[] args) &#123; ClassAsFactory&lt;Employee&gt; fe = new ClassAsFactory&lt;Employee&gt;(Employee.class); print(\"ClassAsFactory&lt;Employee&gt; succeeded\"); try &#123; ClassAsFactory&lt;Integer&gt; fi = new ClassAsFactory&lt;Integer&gt;(Integer.class); &#125; catch(Exception e) &#123; print(\"ClassAsFactory&lt;Integer&gt; failed\"); &#125; &#125;&#125; /* Output:ClassAsFactory&lt;Employee&gt; succeededClassAsFactory&lt;Integer&gt; failed*///:~ ClassAsFactory(Integer.class)失败是因为Integer没有任何默认的构造器。因为这个错误不能在编译期被捕获，所有sun公司建议使用显式的工厂，并限制其类型，是的只能接受实现了这个工厂的类，在显式的工厂中进行实际对象的new时，可以对new的过程进行编译期检查，而通过class.newIntance()这种方式不能再编译期检查到不存在无参构造函数的情况 1234567891011121314151617181920212223242526272829303132interface FactoryI&lt;T&gt; &#123; T create();&#125;class Foo2&lt;T&gt; &#123; private T x; public &lt;F extends FactoryI&lt;T&gt;&gt; Foo2(F factory) &#123; x = factory.create(); &#125; // ...&#125;class IntegerFactory implements FactoryI&lt;Integer&gt; &#123; public Integer create() &#123; return new Integer(0); &#125;&#125; class Widget &#123; public static class Factory implements FactoryI&lt;Widget&gt; &#123; public Widget create() &#123; return new Widget(); &#125; &#125;&#125;public class FactoryConstraint &#123; public static void main(String[] args) &#123; new Foo2&lt;Integer&gt;(new IntegerFactory()); new Foo2&lt;Widget&gt;(new Widget.Factory()); &#125;&#125; ///:~ 其实这种方式只是传递了Class的一种变体。两种方式都传递了工厂对象，Class是一个內建的工厂对象，而上面的方式创建的显式的工厂对象，却获得了编译期检查 1234567891011121314151617181920212223@startumlinterface FactoryI&lt;T&gt;&#123; + create(): T&#125;class Foo2&lt;T&gt;&#123; - x: T + &lt;F extends FactoryI&lt;T&gt; Foo2(F factory)&#125;note right: the construction function\\n receive a factory objectclass Widget&#123;&#125;class WidgetFactory&#123; + create(): Widget&#125;class IntegerFactory&#123; + create(): Integer&#125;FactoryI &lt;|-- WidgetFactoryFactoryI &lt;|-- IntegerFactoryWidget *-- WidgetFactory@enduml 另一种方式是通过模板方法的设计模式实现的：get()是模板方法，而create()是在子类中定义的，用来产生子类类型的对象 123456789101112131415161718192021222324abstract class GenericWithCreate&lt;T&gt; &#123; final T element; GenericWithCreate() &#123; element = create(); &#125; abstract T create();&#125;class X &#123;&#125;class Creator extends GenericWithCreate&lt;X&gt; &#123; X create() &#123; return new X(); &#125; void f() &#123; System.out.println(element.getClass().getSimpleName()); &#125;&#125; public class CreatorGeneric &#123; public static void main(String[] args) &#123; //默认构造函数中会调用父类的构造函数，父类构造函数会调用create()方法 Creator c = new Creator(); c.f(); &#125;&#125; /* Output:X*///:~ 泛型数组正如Erased类中所示，不能new T[]，一般的解决方法就是在任何想要创建泛型数组的地方都使用ArrayList。这将获得数组的行为，以及泛型提供的编译期的类型安全 12345public class ListOfGenerics&lt;T&gt; &#123; private List&lt;T&gt; array = new ArrayList&lt;T&gt;(); public void add(T item) &#123; array.add(item); &#125; public T get(int index) &#123; return array.get(index); &#125;&#125; ///:~ 解决思路： 既然所有数组无论它们持有的类型如何，都具有相同的结构(每个槽位的尺寸和数组的布局),那么看起来应该可以创建一个Object数组，然后将其转型为所希望的数组类型 ch15.8-2 上述实现的问题在于数组将跟踪它们的实际类型，而这个类型是在它们被创建时确定的。因此，即使gia以及被转型为Generic[]，但是这只是为了通过编译期检查而做的工作；而在运行期，gia仍然是一个Object数组 因此，成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组，然后对其转型 ch15.8-3 通过创建一个T[]，在构造函数中创建一个Object数组并转型为T[]，这样就可以通过编译期的检查了。然后在返回（get）时就不需要为其转型了，但是运行期返回的还是Object[]，所有的转型其实都只是为了通过编译期检查。 此外，另一种方式是让类中持有一个Object[]，而不是T[]。这样，在构造函数中创建一个Object数组，然后在返回（get）时对其转型，同样，实际在返回的是一个Object[]，对其向下转型时将会失败。 这看起来其实和上一种方法没有太大的区别，只是转型由构造时进行转型，变为在get时进行转型 123456789101112131415161718192021222324252627282930public class GenericArray2&lt;T&gt; &#123; private Object[] array; public GenericArray2(int sz) &#123; array = new Object[sz]; &#125; public void put(int index, T item) &#123; array[index] = item; &#125; @SuppressWarnings(\"unchecked\") public T get(int index) &#123; return (T)array[index]; &#125; @SuppressWarnings(\"unchecked\") public T[] rep() &#123; return (T[])array; // Warning: unchecked cast &#125; public static void main(String[] args) &#123; GenericArray2&lt;Integer&gt; gai = new GenericArray2&lt;Integer&gt;(10); for(int i = 0; i &lt; 10; i ++) gai.put(i, i); for(int i = 0; i &lt; 10; i ++) System.out.print(gai.get(i) + \" \"); System.out.println(); try &#123; Integer[] ia = gai.rep(); &#125; catch(Exception e) &#123; System.out.println(e); &#125; &#125;&#125; /* Output: (Sample)0 1 2 3 4 5 6 7 8 9java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer;*///:~ 最终的解决方法，还是应该传递一个类型标记Class到构造器中，以便从擦除中恢复类型，使得我们可以创建需要的实际类型的数组。下面的实现中，数组的运行时类型是确切的类型T[] 1234567891011121314151617181920public class GenericArrayWithTypeToken&lt;T&gt; &#123; private T[] array; @SuppressWarnings(\"unchecked\") public GenericArrayWithTypeToken(Class&lt;T&gt; type, int sz) &#123; array = (T[])Array.newInstance(type, sz); &#125; public void put(int index, T item) &#123; array[index] = item; &#125; public T get(int index) &#123; return array[index]; &#125; // Expose the underlying representation: public T[] rep() &#123; return array; &#125; public static void main(String[] args) &#123; GenericArrayWithTypeToken&lt;Integer&gt; gai = new GenericArrayWithTypeToken&lt;Integer&gt;( Integer.class, 10); // This now works: Integer[] ia = gai.rep(); &#125;&#125; ///:~ 15.9 边界边界使得你可以在用于泛型的参数类型上设置限制条件，其最重要的效果就是可以按照定义的边界类型来调用边界类型中的方法，而不仅仅是调用Obejct类型的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657interface HasColor &#123; java.awt.Color getColor(); &#125;class Colored&lt;T extends HasColor&gt; &#123; T item; Colored(T item) &#123; this.item = item; &#125; T getItem() &#123; return item; &#125; // The bound allows you to call a method: java.awt.Color color() &#123; return item.getColor(); &#125;&#125;class Dimension &#123; public int x, y, z; &#125;// This won't work -- class must be first, then interfaces:// class ColoredDimension&lt;T extends HasColor &amp; Dimension&gt; &#123;// Multiple bounds:多重边界class ColoredDimension&lt;T extends Dimension &amp; HasColor&gt; &#123; T item; ColoredDimension(T item) &#123; this.item = item; &#125; T getItem() &#123; return item; &#125; java.awt.Color color() &#123; return item.getColor(); &#125; int getX() &#123; return item.x; &#125; int getY() &#123; return item.y; &#125; int getZ() &#123; return item.z; &#125;&#125;interface Weight &#123; int weight(); &#125; // As with inheritance, you can have only one// concrete class but multiple interfaces:// 多重边界可以同时继承一个类和多个接口class Solid&lt;T extends Dimension &amp; HasColor &amp; Weight&gt; &#123; T item; Solid(T item) &#123; this.item = item; &#125; T getItem() &#123; return item; &#125; java.awt.Color color() &#123; return item.getColor(); &#125; int getX() &#123; return item.x; &#125; int getY() &#123; return item.y; &#125; int getZ() &#123; return item.z; &#125; int weight() &#123; return item.weight(); &#125;&#125;class Boundedextends Dimension implements HasColor, Weight &#123; public java.awt.Color getColor() &#123; return null; &#125; public int weight() &#123; return 0; &#125;&#125; public class BasicBounds &#123; public static void main(String[] args) &#123; Solid&lt;Bounded&gt; solid = new Solid&lt;Bounded&gt;(new Bounded()); solid.color(); solid.getY(); solid.weight(); &#125;&#125; ///:~ 此外，还可以通过继承消除上述实现的冗余。HoldItem直接持有一个对象，因此这种行为被继承到了Colored2，它也要求其参数与HasColor一致。同时，通过继承，也实现了对各个层里的函数的复用 12345678910111213141516171819202122232425262728293031323334class HoldItem&lt;T&gt; &#123; T item; HoldItem(T item) &#123; this.item = item; &#125; T getItem() &#123; return item; &#125;&#125;class Colored2&lt;T extends HasColor&gt; extends HoldItem&lt;T&gt; &#123; Colored2(T item) &#123; super(item); &#125; java.awt.Color color() &#123; return item.getColor(); &#125;&#125;class ColoredDimension2&lt;T extends Dimension &amp; HasColor&gt;extends Colored2&lt;T&gt; &#123; ColoredDimension2(T item) &#123; super(item); &#125; int getX() &#123; return item.x; &#125; int getY() &#123; return item.y; &#125; int getZ() &#123; return item.z; &#125;&#125;class Solid2&lt;T extends Dimension &amp; HasColor &amp; Weight&gt;extends ColoredDimension2&lt;T&gt; &#123; Solid2(T item) &#123; super(item); &#125; int weight() &#123; return item.weight(); &#125;&#125;public class InheritBounds &#123; public static void main(String[] args) &#123; Solid2&lt;Bounded&gt; solid2 = new Solid2&lt;Bounded&gt;(new Bounded()); solid2.color(); solid2.getY(); solid2.weight(); &#125;&#125; ///:~","categories":[{"name":"ThinkingInJava","slug":"ThinkingInJava","permalink":"http://matlabchina.cn/categories/ThinkingInJava/"}],"tags":[{"name":"ThinkingInJava","slug":"ThinkingInJava","permalink":"http://matlabchina.cn/tags/ThinkingInJava/"}]},{"title":"神经网络与深度学习 第三章 深度学习是个什么东西","date":"2018-01-20T10:45:33.000Z","path":"2018/01/20/神经网络与深度学习-第三章-深度学习是个什么东西/","text":"几个基本概念： 机器学习：是很多种方法和模型的总称。 神经网络：是一种机器学习模型，可以说是目前最火的一种。 深度神经网络：就是层数比较多的神经网络。 深度学习：就是使用了深度神经网络的机器学习。 3.1 机器学习监督学习概念：随时在旁边看着你学习，随时纠正你学习中的错误。对于错误学习给予惩罚，对正确学习给予奖励 所有训练数据包括：正确的训练集和错误的训练集。这两种训练集最好在数量上相等，并且样本数量够全。接下来，将训练这些数据并将识别或预测结果与实际的人为标定过的“训练数据”做比较 非监督学习概念：没有人为标定好的训练数据，没有告诉模型哪些数据是正确的，哪些是不正确的。 常见的应用场景：关联规则的学习和聚类将苹果和香蕉混在一起，模型自己去做聚类学习，有可能学习出来很多种类别，除了特征相差较大的苹果和香蕉两种不同的水果外，还能发现某些苹果和香蕉的特殊品种，这种发现是由算法自己找出的。 非监督学习的常见算法包括Apriori算法和K-Means算法 ![ch3.1-3](http://cdn.matlabchina.cn/NNandDL/NN-ch3.1-3.PNG)","categories":[{"name":"神经网络和深度学习","slug":"神经网络和深度学习","permalink":"http://matlabchina.cn/categories/神经网络和深度学习/"}],"tags":[{"name":"神经网络与深度学习","slug":"神经网络与深度学习","permalink":"http://matlabchina.cn/tags/神经网络与深度学习/"}]},{"title":"Python script for Wechat Jumper","date":"2018-01-13T05:08:49.000Z","path":"2018/01/13/sprint-001-b1-python-script-for-Jumper/","text":"Use python to control Android devices How adb works Connect the Android Device with ADB Wrapping ADB command with Python Image Process Get the solider’s postion Get the next stop’s target position Get jumpping distance Get the pressing time Build up the APP Have fun Use python to control Android devicesHow adb worksWhen you start an adb client, the client first checks whether there is an adb server process already running. If there isn’t, it starts the server process. When the server starts, it binds to local TCP port 5037 and listens for commands sent from adb clients—all adb clients use port 5037 to communicate with the adb server. The server then sets up connections to all running devices. It locates emulators by scanning odd-numbered ports in the range 5555 to 5585, the range used by the first 16 emulators. Where the server finds an adb daemon (adbd), it sets up a connection to that port. Note that each emulator uses a pair of sequential ports — an even-numbered port for console connections and an odd-numbered port for adb connections. For example: Emulator 1, console: 5554Emulator 1, adb: 5555Emulator 2, console: 5556Emulator 2, adb: 5557and so on… As shown, the emulator connected to adb on port 5555 is the same as the emulator whose console listens on port 5554. Once the server has set up connections to all devices, you can use adb commands to access those devices. Because the server manages connections to devices and handles commands from multiple adb clients, you can control any device from any client (or from a script). Connect the Android Device with ADB install adb server: download UniversalAdbDriverSetup.msi &amp; install let the android device connect adb servr add the file folder path which contains adb.exe to your computer’s environment start adb server in cmd: adb server enable developer mode in your android device connect android device with your compuer via usb connect android adb client with adb server:run adb devices, if the device is listed like this，that means you have made it to connect your android devices to adb server: 123C:\\Users\\k5tsed&gt;adb devicesList of devices attachedb03db687 device else, you shoud check this: adb怎么连接手机 Now, you have finished connecting android device with adb server, you can run something adb command to control your android devices. For example, you can scrap your screenshot picture with the below command: 1234C:\\Users\\k5d&gt;adb shell screencap /sdcard/screen.pngC:\\Users\\k5d&gt;adb pull /sdcard/screen.png D:/screen.png2878 KB/s (333666 bytes in 0.113s) you can see there is a sceenshot picture in your disk. For more adb command, you can check this: Android adb command. But these two commands are enough for us to implement the our cheating program. Wrapping ADB command with PythonWe have successfully use two commands above to scrap the screenshot picture and transfering to our computer. In python, we can import os module to run ADB commands. The os module inlcudes miscellaneous operating system interfaces, it provides a portable way of using operating system dependent functionality os.system(command)Execute the command (a string) in a subshell. This is implemented by calling the Standard C function system() 1234567891011121314151617181920212223import osfrom random import randomclass adb_wrapper:def get_picture(self): os.system('adb shell /system/bin/screencap -p /sdcard/screenshot.png') os.system('adb pull /sdcard/screenshot.png ../sources/target.png')def press(self, press_time_ms): start_x = str(100 + random() * 900) + ' ' start_y = str(100 + random() * 1500) + ' ' end_x = str(100 + random() * 900) + ' ' end_y = str(100 + random() * 1500) + ' ' press_command = 'adb shell input swipe ' + start_x + start_y + end_x + end_y + str(press_time_ms) os.system(press_command)def restart(self): os.system('adb shell input tap 527 1603')if __name__ == '__main__': adb = adb_wrapper() adb.get_picture() press(self, press_time_ms) In order to simulate pressing screen event for a time period, we use swipe event to precisely control the pressing time. The swipe event can simulate the event of swiping from Star_Point to End_Point with presetting time duration, and the time unit is millisecond(MS). Besides, in order to evade the anti-cheating system, we can swipe from a random point to another random point. restart(self) For restart funtion, we use ‘tap’ command to tap the “重新开始” button. With this function, we can restart the game if the program accidentally failed to jump to next stop. Image ProcessAs we all known, OpenCV (Open Source Computer Vision Library) is a famous and high-performance library of programming functions mainly aimed at real-time computer vision. With this powerful library, we don’t need to have much knowledge about digital image processing, we can still easily finish the pattern recognition, edge detection and etc. Besides, OpenCV supports the deep learning frameworks TensorFlow, Torch/PyTorch and Caffe. In the jumper game, the key varaible is the pressing time, and we can easily know it might be in proportion to the distance between the soilder and the next stop. So, we can divide the task into three steps: get the solider’s postion, get the start point get the next stop’s target position, that’s the end point. Then we can easily get the distance between start point and end point get pressing time, with the distance we get from last step, then it can be multiplied by time-distance coefficientwe to get the pressing time we desire. Get the solider’s postionAs we said above, we use OpenCV library to get the start point and end point. But one more thing, before you start use it, you need to install opencv module. You can install it with pip tool: pip install opencv-python opencv This method uses the unofficial OpenCV PyPi wheels for Linux, Mac and Windows. If you want OpenCV including the Extra contributed modules, instead do: pip install opencv-contrib-python Now, we can use cv2.matchTemplate() method to search and match the given template from a target image. To get the solider’s position, we can simply use the solider template to match the target simillar area. The return value of cv2.matchTemplate() is the correlation coefficent matrix which is corresponding to the image pixel matrix. We have grabbed and fecthed the sceenshot of the game through the adb_wrapper tool above to our workspace. Here you can see what it looks like: jumper006 And the soilder template can be grabbed from any of game screenshot image. It should be like this: jumper005 get_solider_pos(self) So, the get_solider_pos function is implemented as below. For more information about cv2.matchTemplate() of OpenCV, you can check this doc. OpenCV模板匹配 1234567891011121314def get_solider_pos(self): chess = cv2.imread(\"../sources/solider.png\") self.target_image = cv2.imread('../sources/target.png') res = cv2.matchTemplate(self.target_image, chess, cv2.TM_CCOEFF_NORMED) min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res) self.max_loc = max_loc top_left = max_loc center1_loc = (max_loc[0] + 39, max_loc[1] + 189) # self.mark_image = cv2.circle(self.target_image, center1_loc, 30, (255, 0, 0), 3) self.mark_image = cv2.rectangle(self.target_image, max_loc, (max_loc[0] + 75, max_loc[1] + 192), (0, 255, 0), 2) cv2.imwrite('../sources/chess_mark.png', self.mark_image) return max_val, center1_loc After we get the correlation coefficent matrix, we can use cv2.minMaxLoc() to find the min_val, max_val and its’ corresponding min_loc, max_loc of the matrix. It is noted that there are several matching algorithm in the cv2.matchTemplate() function, but the different algorithm have different meaning of max_loc. With the cv2.TM_CCOEFF_NORMED algorithm, the max_loc means the top left corner of the matching target. But other matching algorithm may means rigth bottom corner. So, please be noted. After we get the target matching object’s top left corner’s coordinate, we can translate a fixed number of pixels to get the coordinate of the solider’s bottom center coordinate. In this way, the matching result should look like this: jumper003 Get the next stop’s target positionTo get next stop’s target position, we need to find the next stop’s object, and get the central point of the object. But the next stop’s object include box, desk, and etc. so, we can’t use template matching algorithm. So, my solution is using edge detection to find next object. get_dest(self): Before edge detection, we need to use image fuzzy algorithm to make the objects’ edge more clear. Here we use cv2.GaussianBlur() function to implement that. 高斯模糊 在某些情况下，需要对一个像素的周围的像素给予更多的重视。因此，可通过分配权重来重新计算这些周围点的值。这可通过高斯函数（钟形函数，即喇叭形数）的权重方案来解决。cv::GaussianBlur函数可作为滤波器用下面的方法调用： 1img_rgb = cv2.GaussianBlur(self.target_image, (5, 5), 0) 区别 低通滤波与高斯滤波的不同之处在于：低通滤波中，滤波器中每个像素的权重是相同的，即滤波器是线性的。而高斯滤波器中像素的权重与其距中心像素的距离成比例。 这里(5, 5)表示高斯矩阵的长与宽都是5，标准差取0时OpenCV会根据高斯矩阵的尺寸自己计算。概括地讲，高斯矩阵的尺寸越大，标准差越大，处理过的图像模糊程度越大。 Next, we can use the fuzzied image to get the edge image with cv2.Canny() function. The edge image would be like this if your parameter is proper. 1edge = cv2.Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient ]]]) 必要参数： 第一个参数是需要处理的原图像，该图像必须为单通道的灰度图； 第二个参数是阈值1； 第三个参数是阈值2。 其中较大的阈值2用于检测图像中明显的边缘，但一般情况下检测的效果不会那么完美，边缘检测出来是断断续续的。所以这时候用较小的第一个阈值用于将这些间断的边缘连接起来。 Now, we can get the top point of next target, because the next target’s top edge point is also the top point of the whole image. We can scan each row of the edge image from up to down to get the top non-zero point. By finding this top non-zero point, we can successfully get the next obejct’s top point. Then, we can find the central point of target object from this point. 1np.nonzero(a) 返回数组a中非零元素的索引值数组。 (1) 只有a中非零元素才会有索引值，那些零值元素没有索引值； (2) 返回的索引值数组是一个2维tuple数组，该tuple数组中包含一维的array数组。其中，一维array向量的个数与a的维数是一致的。 After we get the coordinate of top non-zero point, we can start from this top point to shift downward about 40px(or some other numer of pixels), we assue that point was the central point of the target object, first. Then, we get the vertical coordinate(assumed_center_y). Next, we can get the index average of the assumed_center_y-th row from edge image. That’s approximately the center point’s horizontal coordinate. Since we have got assumed center point’s coordinates, we can easily see the above result that the assumed_center_x is very close to our target’s real center point’s horizontal coordinate. So, we can regard this horizontal coordinate as the center_x coordinate. Next, we still need scan from the row of assumed center-point to the bottom of the edge image to get the next non-zero point, that’s exactly the another edge point(bottom point) of target object. Now, we have got the top point and the bottom point of the target object, we can get the average vertical coordinates of these two points, that’s exactly the center-y coordinate. Cheer up…. we finally get the center point of next stop. But you can find that before I search the top point of the object, I split the image into left_image and right_image. Why do I do this?Because in some situation, the next stop’s object is very small, its’ top edge point might be lowwer than the solider’s top edge point. So, I split the image into two images and search each images’ top non-zero point. So, we can compare these two top point, the next object’s top point’s index is smaller than the fake one. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152def get_dest(self): blur_img = cv2.GaussianBlur(self.target_image, (5, 5), 0) cv2.imwrite('../sources/GaussianBlur.png', blur_img) canny_img = cv2.Canny(blur_img, 1, 11) cv2.imwrite('../sources/edge_match.png', canny_img) # split the image into two images left_x_end = self.max_loc[0] - 10 right_x_start = self.max_loc[0] + 78 left_image = canny_img[400:, :left_x_end] right_image = canny_img[400:, right_x_start:] self.mark_image = cv2.rectangle(self.target_image, (0, 0), (self.max_loc[0], 1920), 255, 2) self.mark_image = cv2.rectangle(self.target_image, (right_x_start, 0), (1080, 1920), 255, 2) cv2.imwrite('../sources/split_img.png', self.mark_image) # test # x = [max(row) for row in left_image] # get each row's max vlaue to a single value list # y = np.nonzero(x) # get non zero value's index # print(y) # find the top non zero point, that's edge of dest object left_non_zero_y_index = np.nonzero([max(row) for row in left_image])[0] right_non_zero_y_index = np.nonzero([max(row) for row in right_image])[0] # get the x_top, y_top y_top = 0 if left_non_zero_y_index.size == 0 or ( left_non_zero_y_index.size &gt; 0 and right_non_zero_y_index.size &gt; 0 and left_non_zero_y_index[0] &gt; right_non_zero_y_index[0]): y_top = right_non_zero_y_index[0] + 400 x_top = int(np.mean(np.nonzero(right_image[right_non_zero_y_index[0]]))) + right_x_start self.next_direction = 'right' else: y_top = left_non_zero_y_index[0] + 400 x_top = int(np.mean(np.nonzero(left_image[left_non_zero_y_index[0]]))) self.next_direction = 'left' # find the bottom of the dest object y_bottom = y_top + 40 H, W = canny_img.shape for row in range(y_bottom, H): if canny_img[row, x_top] != 0: y_bottom = row break # get the central point of the object x_center, y_center = x_top, (y_top + y_bottom) // 2 self.mark_image = cv2.circle(self.mark_image, (x_center, y_center), 10, (255, 0, 0), 2) cv2.imwrite('../sources/chess_and_dest_mark.png', self.mark_image) return x_center, y_center Get jumpping distanceFinally, We got the distance betwen the target object and jumpping start point, which we can see the processed result like this: 123456def get_distance(self, solder_pos): dest_x_center, dest_y_center = self.get_dest() self.mark_image = cv2.line(self.target_image, solder_pos, (dest_x_center, dest_y_center),(0, 255, 0), 2) cv2.imwrite('../sources/link_img.png', self.mark_image) distance = ((dest_x_center - solder_pos[0]) ** 2 + (dest_x_center - solder_pos[1]) ** 2) ** 0.5 return distance jumper004 Get the pressing timeIf you think the most difficult thing is getting the distance, I’m gonna to say “don’t be navie, pls”. Actually, distance is not exactly proportional to time, they are in nonlinear relation. So, your must get enough samples to get fitting function. Besides, due to the perspective phenomenon, the same distance in 2-D image, but in different directions, actually represent very different actual distance. So, you need to calculate different fitting functions in different directions. get_press_time(self, solder_pos) 12345678910111213141516171819202122232425262728def get_press_time(self, solder_pos): distance = self.get_distance(solder_pos) print(\"oringin distance:\" + str(distance)) if self.next_direction == 'left': ratio = (0.00345 * distance - 0.6009) * 0.35 # ratio = (distance * 0.001205 + 0.5295) / 1.356 # if ratio &gt;= 1.05: # ratio = 1.012 # if distance &lt;= 400: # ratio *= 0.9 if ratio &gt;= 0.832: ratio = 0.832 print(\"left ratio: \" + str(ratio)) else: # ratio = 1.373 # ratio = distance * 0.001525 + 0.7505 # if ratio &gt;= 1.51: # ratio = 1.49 # if distance &lt;= 350: # ratio *= 0.9 # ratio = -0.0014 * distance + 2.0774 ratio = -0.00003 * (distance ** 2) + 0.0314 * (distance) - 7.3992 # ratio = (-0.0425) * ((distance // 100) ** 2) + 0.3535 * (distance // 100) + 0.5675 if ratio &gt;= 1.35: ratio = 1.35 print(\"right ratio: \" + str(ratio)) press_time = int(distance * ratio) return press_time Build up the APPNow, you can build up your app with all functions and componets above. Here is what I have implemented. 123456789101112131415161718192021222324252627from time import sleepfrom src.adb_cmd import adb_wrapperfrom src.image_process import image_processclass auto_jumpper: def __init__(self): self.processor = image_process() self.adb = adb_wrapper() def main(self): while True: self.adb.get_picture() match_score, chess_loc = self.processor.get_solider_pos() if match_score &lt; 0.85: sleep(3) self.adb.restart() print('restart') sleep(3) continue else: press_time = self.processor.get_press_time(chess_loc) self.adb.press(press_time) sleep(1.5)if __name__ == '__main__': auto_jumpper().main() In the main loop, if the match_score(max solider matching correlation coefficient) is smaller than 0.85, it proves the solider is still jumpping, or game is over. So, we need to tap the restart button. Have funNow, you can have fun with this lillte cheating program. But pls don’t be evil (๑╹◡╹)ﾉ””” score","categories":[{"name":"python","slug":"python","permalink":"http://matlabchina.cn/categories/python/"}],"tags":[{"name":"Jumper","slug":"Jumper","permalink":"http://matlabchina.cn/tags/Jumper/"}]},{"title":"sprint 001: 图解HTTP","date":"2018-01-13T02:55:59.000Z","path":"2018/01/13/sprint-001-图解HTTP/","text":"生是一场遇见，活是一次经验；为他人生，为自己活；生不厌世，活不弃志. Reviewsprint 000PlanningTime: From: 13-Jan-2018 To: 19-Jan-2018 standard work load: 30h User Story 图解HTTP python script for Jumper Backlog python script for Jumper expected work load: 8h priority：2 图解HTTP ch1~ch3 expected work load: 8h priority：1 图解HTTP ch4~ch6 expected work load: 8h priority：1 图解HTTP ch7~ch9 expected work load: 8h priority：2","categories":[],"tags":[]},{"title":"神经网络与深度学习 第二章 构造神经网络","date":"2018-01-09T13:14:52.000Z","path":"2018/01/09/神经网络与深度学习-第二章-构造神经网络/","text":"2.1 构造一个神经元 神经网络基本组成： 信号处理：可以简单的描述为:接受输入信号并汇总输出 $s=p_{1}w_{1}+p_{2}w_{2}+p_{3}w_{3}+…+p_{n}w_{n}+b$ $b$代表神经元本身的特性 传递函数：将信号处理的结果进行格式化输出 2.3 感知机学习 感知机 感知机的学习规则也是一种训练方法，目的是修改神经网络的权值和偏置 $w_{new}=w_{old}+ep$ $b_{new}=b_{old}+e$ $e$表示误差，$e=t-a$，$t$为期望输出，$a$为实际输出 2.4 用代码实现一个感知机 Neuroph：一个基于Java的神经网络框架 1.1 Neuroph基本框架 由两部分组成：一部分是由基于Java开发的API组成；另一部分是图形工具，能直接通过简单的图形化工具构造一个神经网络 1.2 Neuroph API的基本框架 Neuroph Java API主要分成三块： NeuralNetWork LearningRule Layer 工作原理： (1) 神经网络和学习规则对应，神经网络按照一定的学习规则训练相应的数据集 (2) 神经网络由基础的层(Layer)组成，按照结构分为输入层、隐藏层和输出层 (3) 神经网络的每层由最基础的神经元组成 (4) 训练规则包含一个训练集，允许有多个训练集，训练集由单个训练元素组成 Neuroph中的Neuron类，它表示单个神经元的构造 inputConnections：表示神经元的输入连接，一个神经元可以有多个输入 inputFunction: 表示输入函数，通常选择加权求和 netInput：表示净输入,输入函数的输出 output：表示神经元的输入 transferFunction：表示传输函数 error: 神经元的误差 基于Neuroph构造一个感知机（神经元） 基于Neuroph的感知机学习一个简单逻辑运算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.Arrays;import org.neuroph.core.NeuralNetwork;import org.neuroph.core.data.DataSet;import org.neuroph.core.data.DataSetRow;import org.neuroph.nnet.Perceptron;public class NeurophLearning &#123; public static void main(String[] args) &#123; /** * test AND */ //set up AND training data set DataSet trainAndSet = new DataSet(2, 1); trainAndSet.addRow(new DataSetRow(new double[]&#123;0, 1&#125;, new double[]&#123;0&#125;)); trainAndSet.addRow(new DataSetRow(new double[]&#123;1, 0&#125;, new double[]&#123;0&#125;)); trainAndSet.addRow(new DataSetRow(new double[]&#123;1, 1&#125;, new double[]&#123;1&#125;)); trainAndSet.addRow(new DataSetRow(new double[]&#123;0, 0&#125;, new double[]&#123;0&#125;)); // set up perceptron NeuralNetwork myPerceptron = new Perceptron(2, 1); //start to learn System.out.print(\"start training AND: \"); myPerceptron.learn(trainAndSet); myPerceptron.save(\"AND_learn_result.nnet\"); //add new rows for testing trainAndSet.addRow(new DataSetRow(new double[]&#123;2, 3&#125;, new double[]&#123;0&#125;)); testNeuralNetwork(myPerceptron, trainAndSet); /** * test XOR * can't finish, cause the perceptron can't process the */ //set up XOR training data set DataSet trainXorSet = new DataSet(2, 1); trainXorSet.addRow(new DataSetRow(new double[]&#123;0, 0&#125;, new double[]&#123;0&#125;)); trainXorSet.addRow(new DataSetRow(new double[]&#123;0, 1&#125;, new double[]&#123;1&#125;)); trainXorSet.addRow(new DataSetRow(new double[]&#123;1, 0&#125;, new double[]&#123;1&#125;)); trainXorSet.addRow(new DataSetRow(new double[]&#123;1, 1&#125;, new double[]&#123;0&#125;)); // add training set to perceptron System.out.print(\"start training XOR: \"); myPerceptron.learn(trainXorSet); myPerceptron.save(\"XOR_learn_result.nnet\"); testNeuralNetwork(myPerceptron, trainXorSet); &#125; public static void testNeuralNetwork(NeuralNetwork nnet, DataSet tset) &#123; for (DataSetRow dataRow : tset.getRows()) &#123; nnet.setInput(dataRow.getInput()); nnet.calculate(); double[] networkOutput = nnet.getOutput(); System.out.print(\"Input: \" + Arrays.toString(dataRow.getInput())); System.out.println(\" Output: \" + Arrays.toString(networkOutput)); &#125; &#125;&#125; Output： 12345678start training AND: Input: [0.0, 1.0] Output: [0.0]Input: [1.0, 0.0] Output: [0.0]Input: [1.0, 1.0] Output: [1.0]Input: [0.0, 0.0] Output: [0.0]Input: [2.0, 3.0] Output: [1.0]start training XOR: Disconnected from the target VM, address: &apos;127.0.0.1:49507&apos;, transport: &apos;socket&apos;Process finished with exit code 1 可以看到网络已经正确的记忆了AND逻辑，并成功的预测了Input= [2.0, 3.0] 时的结果 但是当使用该感知机对XOR逻辑进行学习时，程序却未能成功输出正确结果 2.5 构造一个神经网络 单个神经元有不同的作用，当这些不同种类的神经元依据某种结构联系起来时，就成为神经网络 线性不可分 可以看到AND逻辑和OR逻辑都可以用一条直线区分两类事物，而XOR逻辑无法用一条直线进行区分 解决XOR逻辑问题–多层神经网络 3.1 在神经网络上多加一层，并且利用“后向传播”学习方法，可以解决XOR问题 3.2 神经网络分层的概念 (1) 感知器：一种双层神经网络模型：一层为输入层（即：输入刺激，也就是输入节点不参与计算）；另一层具有计算单元，可以通过监督学习建立模式判别的能力 (2) 多层神经网络–前馈神经网络 特点：前馈网络的各神经元接受前一级输入，并输出到下一级，无反馈 节点：输入节点、输出节点 (3) 计算单元：可以有任意个输入，但是只有一个输出，输出可耦合到任意多额其他输入节点 (4) 层：可见层–输入和输出节点；隐层–中间层 3.3 解决XOR逻辑问题: 构造如下图所示的两层神经网络： 第一层上侧的神经元 净输入为：$2p_{1}+2p_{2}-1$ 净输入与$p_{1}$和$p_{2}$的关系为： 该结果亦可表示为： 第一层下侧的神经元 净输入为：$-2p_{1}-2p_{2}+3$ 净输入与$p_{1}$和$p_{2}$的关系为： 该结果亦可表示为： 最后，由输出神经元对两个神经元的数据进行整合，这里使用AND逻辑操作，得到如下图所示的正确的XOR运算结果 3.4 XOR问题的代码实现 用Neuroph实现多层感知机，也就是多层神经网络，只需要调用MultiLayerPerceptron类，并设定好层数和每层的神经元数量就能实现一个多层神经网络 1234567891011121314151617181920212223242526272829303132333435public class NeurophLearning &#123; public static void main(String[] args) &#123; /** * test XOR with multi layer perceptron * info: multi layer perceptron have multi rules to sort the output */ /** * define multiLayerPerceptron * transmission function: TransferFunctionType.TANH * input neuron num: 2 * hidden neuron num: 3 * output neuron num: 1 */ MultiLayerPerceptron multiLayerPerceptron = new MultiLayerPerceptron(TransferFunctionType.TANH, 2, 30, 1); System.out.print(\"start training XOR with multi layer: \"); multiLayerPerceptron.learn(trainXorSet); multiLayerPerceptron.save(\"Multi_Layer_XOR_learn_result.nnet\"); testNeuralNetwork(multiLayerPerceptron, trainXorSet); &#125; public static void testNeuralNetwork(NeuralNetwork nnet, DataSet tset) &#123; for (DataSetRow dataRow : tset.getRows()) &#123; nnet.setInput(dataRow.getInput()); nnet.calculate(); double[] networkOutput = nnet.getOutput(); System.out.print(\"Input: \" + Arrays.toString(dataRow.getInput())); System.out.println(\" Output: \" + Arrays.toString(networkOutput)); &#125; &#125;&#125; OutPut： 1234start training XOR with multi layer: Input: [0.0, 0.0] Output: [0.054516757895040555]Input: [0.0, 1.0] Output: [0.8398140650473199]Input: [1.0, 0.0] Output: [0.8300494421275931]Input: [1.0, 1.0] Output: [-0.043845105754237494] 2.6 解决一些实际问题 识别动物 输入：20项特征值，每一项特征用0/1表示 输出：7项输出，每一项输出，代表某一类动物的概率 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class AnimalRecognition &#123; public static void main(String[] args) &#123; AnimalRecognition animalRecognition=new AnimalRecognition(); animalRecognition.recognize(); &#125; public void recognize() &#123; String trainningSetFilePath = \"data/animal_data.txt\"; int inputsCount = 20; int outputsCount = 7; //get dataSet from data file DataSet dataSet = DataSet.createFromFile(trainningSetFilePath, inputsCount, outputsCount, \"\\t\", true); /** * define multilayer neuralNetWork * 20 inputs, 7 outputs, 22 hide neurons */ MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 22, outputsCount); /** * define learning rule * learning rate = 0.2, max error = 0.01 */ MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule(); learningRule.setLearningRate(0.2); learningRule.setMaxError(0.01); /** * start learning */ neuralNet.learn(dataSet); System.out.println(\"Training completed...\"); /** * start testing */ System.out.println(\"Testing network...\"); testNeuralNetwork(neuralNet,dataSet); &#125; private void testNeuralNetwork(NeuralNetwork neuralNet,DataSet dataSet)&#123; for (DataSetRow dataRow : dataSet.getRows()) &#123; neuralNet.setInput(dataRow.getInput()); neuralNet.calculate(); double[] networkOutput = neuralNet.getOutput(); System.out.print(\"Input: \" + Arrays.toString(dataRow.getInput())); System.out.println(\" Output: \" + Arrays.toString(networkOutput)); &#125; &#125;&#125; 股票指数预测 2.1 基本思路：训练第1天到第4天的数据（1~3天作为输入，第4天作为输出），找出特征并学习；然后训练第2天道第5天的数据，然后训练第3天到第7天的数据，以此类推…训练完所有30天的内容，然后用第27~30天的数据作为输入，去预测第31天的数据 2.2 实现： 先将每天的股票指数除以10000，用于归一化 定义网络的层数、输入数、输出数、学习速率、最大误差、最大迭代数、神经元个数 按照经验值，神经元个数为$2n+1$,$n$是输入个数 3.3 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class PredictionMaster &#123; public void predicte() &#123; /** * define NeuralNetwork * 4 inputs, 1 output, 2n+1=9 neurons * learningRate = 0.7 * maxError = 0.001 * maxIterations = 10000 */ int maxIterations = 10000; NeuralNetwork neuralNetwork = new MultiLayerPerceptron(4, 9, 1); MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNetwork.getLearningRule(); learningRule.setLearningRate(0.7); learningRule.setMaxError(0.001); learningRule.setMaxIterations(maxIterations); double maxIndex = 10000.0D; /** * add training data into training data set */ String trainingSetFilePath = \"data/stock_index_data.txt\"; int inputsCount = 4; int outputsCount = 1; DataSet dataSet = DataSet.createFromFile(trainingSetFilePath, inputsCount, outputsCount, \"\\t\", true); /** * start learning */ neuralNetwork.learn(dataSet); /** * test model */ DataSet testDataSet = new DataSet(4, 1); testDataSet.addRow(new DataSetRow(new double[]&#123;3504, 3508, 3124, 3214&#125;, new double[]&#123;0&#125;)); testNeuralNetwork(neuralNetwork, testDataSet); &#125; private void testNeuralNetwork(NeuralNetwork neuralNet, DataSet dataSet) &#123; for (DataSetRow dataRow : dataSet.getRows()) &#123; neuralNet.setInput(dataRow.getInput()); neuralNet.calculate(); double[] networkOutput = neuralNet.getOutput(); System.out.print(\"Input: \" + Arrays.toString(dataRow.getInput())); System.out.println(\" Output: \" + Arrays.toString(networkOutput)); &#125; &#125; public static void main(String[]args)&#123; PredictionMaster predictionMaster=new PredictionMaster(); predictionMaster.predicte(); &#125;&#125;","categories":[{"name":"神经网络和深度学习","slug":"神经网络和深度学习","permalink":"http://matlabchina.cn/categories/神经网络和深度学习/"}],"tags":[{"name":"神经网络与深度学习","slug":"神经网络与深度学习","permalink":"http://matlabchina.cn/tags/神经网络与深度学习/"}]},{"title":"Docker技术入门与实战-第二十一章 Docker相关项目","date":"2018-01-07T04:23:53.000Z","path":"2018/01/07/Docker技术入门与实战-第二十一章-Docker相关项目/","text":"21.1 平台即服务PaaSPaaS是希望提供一个统一的操作系统平台环境，让所有软件直接运行在上面，而无需复杂配置。而Docker所具有的应用封装，为实现PaaS提供了便利 Deis 开源的PaaS项目，基于Go语言实现 基于Docker项目和CoreOS项目 遵循SaaS应用的“十二因素”风格 十二因素：是指一套SaaS应用所遵循的风格，包括对代码、依赖、配置、后端服务、生命周期、进程、端口、开发、可丢弃性、开发与生产差异性、日志、管理等十二个方面的规定 Flynn 针对一些SOA（Service Oriented Architecture，大规模分布式系统所采用的架构风格，需要功能组件之间的松耦合）产品在部署到公用云的过程中，往往需要大量的人工部署和维护大量不同功能组件的问题 基于Heroku项目，受到OMege概念，实现简单可控的部署，自由扩展，并提供数据库管理等功能。 还可以方便的实现一套比较理想的PaaS方案 Reference: OMege概念来源：Omega: flexible, scalable schedulers for large compute clusters 21.2 持续集成 Drone项目利用Docker技术，实现持续集成平台服务 提供支持Github、Bitbucket和Google Code等第三方代码托管平台的持续集成服务 21.3 管理工具目前Docker对单个容器的操作已经提供了功能强大的命令行操作和API操作接口；但是多容器的管理方面存在两大缺点： 缺乏同时对容器集群进行管理的方案 缺乏图形化界面的管理平台 目前，对Docker集群的管理的几个开源项目主要有： Citadel 目标：提供一套在由Docker容器构成的集群中对容器进行调度的工具 主要包括：集群管理组件、调度组件 Shipyard 基于Citadel项目 目标：提供一套对Docker集群中资源进行管理的工具 最大的特点：在核心部件之外还支持扩展镜像，可以根据需求灵活实现应用负载均衡、集中日志管理和自动化部署等功能 此外，还提供web界面，功能更强大的命令行操作接口和统一的API Kubernetes 目标：为Docker工作负载构建一个精致的、可扩展的便携式管理框架。它允许客户像谷歌管理搜索和Gmail等超大规模应用程序一样来管理他们的应用程序 核心概念：容器组，即一批工作与同一物理工作节点的容器。这些容器具有相同的网络命名空间、IP地址和存储配置，可以根据实际情况进行端口映射 网络管理：Kubernetes有一个与DSN非常相似的网络管理概念：通过一个服务代理创建一个可以分配给任意数目容器的IP地址，前段的应用程序或使用该服务的用户仅通过这一IP地址调用服务，不需要关心其他细节 DockerUI 主要基于html/js实现，遵循MIT协议 Panamax 基于Docker、CoreOS、Fleet项目，期望用一套优雅的界面来实现对负责Docker容器应用的管理。例如，利用拖拽来完成操作 seagull 小米工程师陈迪豪发布的一个开源Docker容器和镜像的Web界面的管理工具 实现原理：基于Go实现，集成了Beego、AngularJS、Bootstrap、Bower、JQuery和Docker等工具。主要利用在宿主机上运行一个Web服务，通过Beego实现的API服务器不断请求Docker本地套接字一管理Docker 使用步骤： 下载镜像：sudo docker pull tobegit3hub/segull 运行镜像：sudo docker run -d -p 10086：10086 -v /var/run/docker.sock:/var/run/docker.socketobegit3hub/seagull Dockerfile 21.4 编程开发 Docker的服务端提供了REST风格的API，通过使用各种编程语言对这些API的进一步封装，可以提供给各种编程语言来调用Docker服务端的服务 例如dcoker-py项目就提供了对Docker服务端的API接口的再封装，以供Python编程语言方便的调用 1234$ sudo python&gt;&gt;&gt; import docker&gt;&gt;&gt; c=docker.Client(base_url='unix://var/run/docker.sock',version='1.15',timeout=10)&gt;&gt;&gt; c.info() 实际上，执行Docker命令的时候，也是通过Docker提供的客户端进行了封装 21.5 其他项目 CoreOS 目标：提供一个基于Docker的轻量级容器化的Linux发行版。通过简化系统架构和提供灵活的应用部署来简化数据中心的复杂度和维护成本 容器化的Linux：不使用包管理工具，将所有应用都容器化。彼此隔离，以提高系统安全性。运行期间，系统分区都是只读状态 配合etcd（一套分布式高可用的键值数据库）、fleet（CoreOS集群的管理工具）等工具，CoreOS也将适用于在大规模集群环境中进行使用 Fig 问题：在使用Docker的过程中，很多时候会遇到将部署的多个容器进行连接的需求。比如，将web容器和db容器进行连接的需求 Fig项目的作用：在同一个配置文件中可以定义依赖的镜像和容器之间的连接关系，并通过一条简单的命令完成部署,例如： 123456789web: build: . command: python app.py links: -db ports: - \"8000:8000\"db: image: postgres OpenStack支持 OpenStack 一套开源的IaaS实现方案 基于Python语言实现 OpenStack支持Docker OpenStack目前除了用于管理众多的虚机之外，其计算服务Nova已经支持了对Docker的驱动 此外,还支持通过Stack管理引擎Heat子项目来使用模板管理Docker容器 dockerize 主要提供两个功能： 一是对依赖配置文件的应用，能根据容器启动配置的环境变量自动生成应用所需要的配置文件 而是将应用输出的日志信息重定向到STDOUT和STDERR 例如，nginx服务器启动时的配置文件可以通过dockerize命令根据其模板文件进行自动生成 dockerize的模板文件 Nginx的Dockerfile 最后的CMD命令中利用-tempalte参数指定了配置模板的位置，以及生成的配置文件的位置 启动容器：sudo docker run -p 80:80 -e PROXY_URL=&quot;http://localhost&quot; --name mynginx -d nginx libcontainer、libchan、libswarm libcontainer: 目标：实现容器技术的统一API Docker计划逐步脱离LXC的底层实现，而迁移到libcontainer上。该项目将为容器技术的发展带来更大的可能性，比如实现多种平台（包括windows平台）之间容器的迁移 libchan、libswarm都是为了Docker容器集群服务的 libchan试图在网络服务之间达到一套“channel”系统。它宣称将大招适合现代各种微服务的极轻量级的网络服务库，并且支持In-Memory Go channel、Unix Socket、Raw TCP、TLS、HTTP2/SPDY、Websocket等多种协议 libswarm基于libchan,目标是一套组件网络服务的最小工具集。它定义了在分布式系统中各种服务组件之间相互通信的标准接口，并且试图实现一整套的网络服务组件。其目标组件包括Docker Server、Docker Client、SSH tunnel、Etcd、SkyDNS、Mesos、OpenStack Nova、Google Compute等各种服务。使用它可以在同一机器上同时管理运行在不同主机上的Docker容器，任意的替换集群中的各种服务，包括服务发现、DNS。libswarm实际上是试图实现一套基础系统，其他各种集群服务作为一个功能模块与libswarm对接。 21.6 本章小结 基于Docker的PaaS和持续集成这两方面，是Docker技术的两大“杀手级应用”，充分发挥出了Docker的技术优势 在具体的生产环境中使用Docker，则无法绕开容器的管理和基于容器的API接口进行开发的需求，特别是大规模的容器管理。","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第二十章 高级网络配置","date":"2018-01-03T11:46:28.000Z","path":"2018/01/03/Docker技术入门与实战-第二十章-高级网络配置/","text":"20.1 网络启动与配置参数 基本过程： A. Docker服务启动时会在主机上自动创建一个docker0的虚拟网桥，并从本地未占用的私有网段钟随机分配一个IP给docker0； 例如：典型的172.17.42.1，掩码为255.255.0.0. B. 当创建容器时，会同时创建一个veth pair接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内(eth0),另一端在docker0上（vethAQI2QT）。且eth0上述docker0在同一网段内 网络相关参数的配置 配置Docker网络相关参数的命令，有些只有在启动Dcocker服务时才能配置，而且不能立马生效 下面两个命令既可以在启动服务时指定，也可以在启动容器时指定 –dns=IP_ADDRESS :使用指定的DNS服务器 –dns-search=DOMAIN ：指定DNS搜索域 有些选项只能在启动容器时指定 20.2 配置容器的DNS和主机名 相关配置文件容器中关于DNS和主机名的配置和Linux系统的配置方式是一致的，都是通过/etc/resolv.conf、/etc/hostname、/etc/hosts三个文件进行配置的 /etc/resolv.conf文件在创建容器时会与主机的/etc/resolv.conf保持一致 /etc/hosts:默认只记录了容器自身的一些地址和名称 /etc/hostname:记录了容器的主机名 容器内修改配置文件容器启动后再修改这三个配置文件的话，都只能在运行的容器中保留，一旦容器终止或重启，这些配置将不会被保存下来，也不会被docker commit提交 通过启动参数指定如果用户想自定义容器的配置，可以在创建或启动容器时使用参数进行指定 20.3 容器访问控制 容器访问外部网络容器默认情况下是可以访问到宿主机本地的；容器访问外部网络需要通过宿主机进行转发，在宿主机系统中，检查转发是否打开： 12felix@felix-ubuntu17:/sys/fs/cgroup/memory/docker$ sudo sysctl net.ipv4.ip_forwardnet.ipv4.ip_forward = 1 此外，在启动容器时，可以设定--ip-forward=true，docker服务会自动打开宿主机系统的转发服务 容器见访问容器间是否能相互访问取决于两个方面： 网络拓扑是否已经连通：默认情况下，所有容器都会连接到docker0网桥上，因此默认情况下网络拓扑是连通的 本地系统的防火墙软件（iptables）是否允许访问通过：这主要取决于iptables的规则 2.1 访问所有端口 当前容器启动时，通过参数--icc=true|false配置一条iptables的FORWARD链策略；也可以在/etc/default/docker文件中增加一条配置DOCER_OPTS==--icc=false来默认禁止容器间的相互访问 但是如果在容器启动时，有指定了--iptables=false，则上述两个方式都将修改不了宿主机上的iptables规则 2.2 访问指定端口 虽然使用--icc=false禁止了容器间的相互访问，但是，仍然可以通过--link=CONTAINER_NAME:ALIAS选项将两个容器暴露的端口互联，同时在iptables中卫两个互联的容器分别添加一条ACCEPT规则 20.4 映射容器端口到宿主主机的实现默认情况下，容器可以主动访问到外部网络，但是外部网络是无法访问到容器的 容器访问外部网络的实现 网络拓扑 某内部容器的ip为:172.17.0.2 宿主机本地ip为：10.0.2.15 容器要访问外部网络，需要对容器对外网的访问进行源地址映射(SNAT),修改访问源地址为本地系统的IP地址10.0.2.15。映射也是通过iptables的源地址伪装操作实现的 1234567felix@felix-ubuntu17:/sys/fs/cgroup/memory/docker$ sudo iptables -t nat -nvL POSTROUTINGChain POSTROUTING (policy ACCEPT 6280 packets, 700K bytes)pkts bytes target prot opt in out source destination 210 12288 MASQUERADE all -- * !docker0 172.17.0.0/16 0.0.0.0/0 41 5785 MASQUERADE all -- * * 10.0.3.0/24 !10.0.3.0/24 0 0 MASQUERADE tcp -- * * 172.17.0.2 172.17.0.2 tcp dpt:8080 0 0 MASQUERADE tcp -- * * 172.17.0.2 172.17.0.2 tcp dpt:1521 POSTROUTING链的规则就是负责网包离开主机前，改写其源地址 将所有源地址在172.17.0.0/16网段内，且不是从docker0接口发出的流量（即从容器中出来的流量），动态伪装成从系统网卡发出 外部访问容器实现启动容器时，通过-p或者-P参数来映射容器内的端口到宿主机的端口上。而这一切的实现都是通过添加iptables的nat表中的规则实现的，将外部来的访问目的IP地址进行目标地址转换DNAT，将目标地址修改为容器的IP地址 PREROUTING链负责包到达网络接口时，改写其目的地址，将所有流量都扔到DOCKER链上；接着，DOCKER链将所有不是从docker0进来的网络（即非外部网包）将目标端口为32769的连接，修改为目标地址172.17.0.2，目标端口为1521 12345678910felix@felix-ubuntu17:~$ sudo iptables -t nat -nvLChain PREROUTING (policy ACCEPT 3 packets, 174 bytes)pkts bytes target prot opt in out source destination 0 0 DOCKER all -- * * 0.0.0.0/0 0.0.0.0/0 ADDRTYPE match dst-type LOCALChain DOCKER (2 references)pkts bytes target prot opt in out source destination 0 0 RETURN all -- docker0 * 0.0.0.0/0 0.0.0.0/0 0 0 DNAT tcp -- !docker0 * 0.0.0.0/0 0.0.0.0/0 tcp dpt:32768 to:172.17.0.2:8080 0 0 DNAT tcp -- !docker0 * 0.0.0.0/0 0.0.0.0/0 tcp dpt:32769 to:172.17.0.2:1521 20.5 配置docker0网桥 Docker服务默认会创建一个名称为docker0的Linux网桥,它在内核层连通了其他的物理或者虚拟网卡，这样就将所有容器和本地主机都放在了同一个物理网络 1234felix@felix-ubuntu17:~$ sudo brctl showbridge name bridge id STP enabled interfacesdocker0 8000.0242eef0cef5 no veth186b8f1lxcbr0 8000.00163e000000 no 每次创建一个新容器的时候，docker从可用的地址段中选择一个空闲的IP地址分配给容器的eth0端口，并且使用本地主机上的docker0接口的IP作为容器的默认网关 1234567891011felix@felix-ubuntu17:~$ sudo docker run -it -p 8088:80 busybox:latest /bin/sh/ # ip addr show eth017: eth0@if18: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff inet 172.17.0.3/16 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::42:acff:fe11:3/64 scope link valid_lft forever preferred_lft forever/ # ip routedefault via 172.17.0.1 dev eth0 172.17.0.0/16 dev eth0 scope link src 172.17.0.3 实际上，Linux网桥可以很容易替换为OpenvSwitch等功能更强大的网桥实现，可以支持VLan等属性 20.6 自定义网桥除了默认的docker0网桥，用户可以指定网桥的连接各个容器 在启动Docker服务时： 使用启动参数指定-b BRIDGE或者--bridge=BRIDGE 修改Docker服务的默认配置文件 12$ echo 'DOCKER_OPTS=\"-b=bridge0\" &gt;&gt; /etc/default/docker'$ sudo service docker start 在服务已经运行时 20.7 创建一个点到点连接 default：默认情况下，Docker会将所有容器连接到docker0提供的虚拟子网中 requirement: 但是，用户有时候只需要两个容器之间可以直接通信，而不需要经过docker0网桥 solution: 创建一对peer接口，分别放到两个容器中，配置成点对点链路类型即可 20.8 工具和项目 pipework: 一个shell脚本封装了一些操作，可以简化在比较复杂的场景中对容器连接的操作命令 playgroud: 提供完整的Dokcer容器网络拓扑管理的Python库，包括了路由、NAT防火墙、以及一些提供HTTP、SMTP等服务器的实现 利用playgroud，用户可以提前配置好容器的拓扑，然后一条命令，启动多个容器并构成互联关系 libswarm 目标：打造管理Docker网络的最小化工具集 主要目标：定义分布式系统各个组件之间通信的统一接口，以实现多种平台上的Docker容器操作的一致性，隐藏下层不同的实现接口 使用libswarm可以实现，在同个控制端同时查看、管理运行在多个不同主机和平台上的Docker镜像、容器；引入更强大的服务发现和集群系统 20.9 本章小结 目前来看，Docker网络所提供的功能都十分简单，且基本上都是依赖于Linux操作系统上的现有技术 随着Docker应用在各种分布式环境，特别是云平台，网络方面的需求和瓶颈将会大量出现，而且不少都是新问题","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第十九章 Docker安全","date":"2018-01-03T10:57:03.000Z","path":"2018/01/03/Docker技术入门与实战-第十九章-Docker安全/","text":"Docker是在Linux操作系统层面的虚拟化实现，运行在容器内的进程，跟运行在本地系统的 进，本质上并无区别。因此，不适合的安全策略可能会直接给本地系统带来风险。 Docker容器的安全性，很大程度依赖于Linux系统本身，因此，其安全性评估主要参考以下几个方面： Linux内核的命名空间机制提供的容器隔离安全 Linux控制组机制对容器资源的控制能力安全 Linux内核的能力机制所带来的操作权限安全 Docker程序（特别是服务端）本身的抗攻击性 其他安全增强机制（包括AppArmor、SELinux等）对容器安全性的影响 19.1 命名空间隔离的安全 当Docker启动一个容器时，Docker将在后台为容器创建一个独立的命名空间。 命名空间提供了最基础也是最直接的隔离，在容器中运行的进程不会被运行在本地主机上的进程和其他容器通过正常渠道发现和影响 与虚拟机方式相比，通过命名空间来实现的隔离并不是那么绝对。运行在容器中的应用可以寄直接访问系统内核和部分文件系统。因此，用户必须保证容器中的应用是安全可信的（这和保证运行在系统中的软件是可信的一个道理）。实际上，Docker自1.30版本其对镜像引入了签名系统，用户可以通过签名来验证镜像的完整性和正确性。 19.2 控制组资源控制的安全 当Docker启动一个容器时，Docker将在后台为容器创建一个独立的控制组策略集合 控制组不仅可以确保各个容器资源的分配和资源的限制；更重要的是，它也确保的当发生在容器内的资源压力不会影响到本地主机系统和其他容器，这对于防止DDoS攻击时必不可少的 19.3 内核能力机制 传统的Unix系统对进程权限只有root权限和非root权限；Linux内核自2.2版本以后开始支持能力机制，它将权限划分为更加细粒度的操作能力，既可以作用在进程上，也可以作用在文件上 Docker启动的容器被严格限制只允许使用内核的一部分能力，包括chown、dac_override、fowner、kill等。容器内使用这些特权能力时都是由容器意外的支持系统来进行管理的 默认情况下，Docker采用“白名单”机制，禁用“必需功能”之外的其他权限。当然，用户也可以根据需要来为Docker容器启用额外的权限 19.4 Docker服务端的防护 由于Docker允许用户在主机和容器间共享文件夹，同时不需要限制容器的访问权限。因此，必须确保只有可信的用户才可以访问到Docker服务 为了加强对服务端的保护： Docker的RESTAPI在0.5.2之后采用了本地的Unix套接字取代了原先绑定在127.0.0.1上的TCP套接字，因为后者容易遭到跨站脚本攻击 采用VPN、SSL、HTTPS和证书来加强访问安全 由于最近的Linux命名空间机制将可以实现使用非root用户来运行全功能的容器。因此，Docker自身改进安全防护的目标是实现以下两个重要安全特性： 19.5 其他安全特性 除了能力机制外，还可以利用一些现有的安全软件或机制来增强Docker的安全性，例如： 在内核中启用GRSEC和PAX，这将增加更多的编译和运行时的安全检查；并通过地址随机化机制来避免恶意探测等。启用该特性不需要Docker进行任何配置 使用一些有增强安全特性的容器模板，比如待遇AppArmor的模板和Redhat带有SELinux策略的模板。这些模板提供了额外的安全特性 用户可以自定义更加严格的访问控制机制来定制安全策略 此外，在将文件系统挂载到容器内部的时候，可以通过配置制度模式来避免容器内的应用通过文件系统破化外部环境 19.6 本章小结 在使用Docker过程中，安全方面应当注意的是：","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第十八章 Docker核心技术","date":"2018-01-02T14:54:58.000Z","path":"2018/01/02/Docker技术入门与实战-第十八章-Docker核心技术/","text":"早期的Docker底层是通过LXC技术实现的；自Docker 0.9版本以后，Docker除了继续支持LXC格式之外，还开始引入自家的libcontainer，试图打造更通用的底层容器虚拟化库 Docker的底层依赖的核心技术主要包括： Linux操作系统的命名空间（Namespaces） 控制组(Control Group) 联合文件系统(Union File Systems) Linux虚拟网络支持 18.1 基本架构 Docker采用标准的C/S架构 1.1 服务端 Docker daemon一般在宿主主机后台运行，作为服务端接受来自客户的请求 Docker daemon采用专门的Engine模块来分发管理各个来自客户端的任务 Docker服务端默认监听本地的 unix:///var/run/docker.sock套接字，只允许本地的root用户访问 可以通过-H选项来修改监听的方式，例如：sudo docker -H 0.0.0.0:1234 -d &amp; Ubuntu中，Docker服务端的默认启动配置文件在/etc/default/docker 1.2 客户端 客户端默认通过本地的unix:///var/run/docker.sock套接字向服务端发送命令 如果服务端更改了监听的套接字，那么客户端可以通过-H参数指定套接字,例如：sudo docekr -H tcp://127.0.0.1:1234 version 18.2 命名空间 每个容器都可以拥有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间彼此互不影响 要想实现虚拟化，除了要对内存、CPU、网络IO、硬盘IO、存储空间等进行限制外；还要实现文件系统、网络、PID、UID、IPC等等相互隔离 Linux系统对于命名空间功能的逐步完善，在Linux上已经可以实现上述的所有需求，让某些进程在彼此隔离的命名空间中运行。虽然，这些进程都共用一个内核和某些运行时环境（runtime，例如一下系统命令和系统库），但是彼此是不可见的–他们都认为自己是独占系统 进程命名空间 Linux通过命名空间来管理进程号，对于同一进程，在不同命名空间中，看到的进程号是不同的。 进程命名空间是一个父子关系的结构，子空间的进程对于父空间是可见的。但是，新fork出的进程在父命名空间和子命名空间将分别有一个进程号来对应。 网络命名空间 一个网络命名空间为进程提供了一个完全独立的网络协议栈的视图 Docker采用虚拟网络设备（Virtual NetWork Device）的方式，将不同命名空间的的网络设备连接到一起。默认情况下，虚拟网卡将同本地主机的docker0网桥连接在一起。 使用brctl show指令就可以查看连接到宿主主机docker0网桥的虚拟网口 IPC命名空间 容器中进程交互还是采用了Linux常见的进程间通信的方法（IPC），包括信号量、消息队列、共享内存等 同一个IPC名字空间内的进程可以彼此可见，允许进行交互；不同空间的进程则无法交互 挂载命名空间 类似于chroot，将一个进程放到特定的目录执行 挂载命名空间允许不同命名空间的进程看到的文件结构不一样，这样每个命名空间中的进程所看到的文件目录彼此被隔离 UTS命名空间 UTS（UNIX Time-sharing System）命名空间允许每个容器都拥有独立的主机名和域名 默认情况下，Docker容器的主机名就是容器的ID 用户命名空间 每个容器都有不同的用户和组ID 每个容器都可以有root账户，更宿主主机不在一个命名空间 18.3 控制组 控制组(CGroups)是Linux内核的一个特性：主要用来对共享资源（如内存、CPU）进行隔离、限制、审计等。只有能控制分配到容器的资源，Docker才能避免多个容器同时运行时的资源竞争 控制组可以提供对容器的内存、CPU、磁盘IO等资源进行限制和计费管理 控制组的设计目标是：为不同的应用提供统一的接口。从控制单一进程（比如nice工具），到系统级虚拟化（包括OpenVZ，LXC等） 控制组主要提供以下功能： 资源限制 优先级：设置组获得资源的优先级 资源审计：记录某个进程使用CPU的时间 隔离：为组隔离名字 控制：挂起、恢复和重启动等操作 查看Docker对各个容器（进程）的资源限制 123456789101112131415161718192021222324252627282930313233felix@felix-ubuntu17:~/docker/weblogic_docker$ cd /sys/fs/cgroup/memory/docker/felix@felix-ubuntu17:/sys/fs/cgroup/memory/docker$ lltotal 0drwxr-xr-x 3 root root 0 1月 3 17:50 ./dr-xr-xr-x 7 root root 0 1月 3 17:46 ../-rw-r--r-- 1 root root 0 1月 3 17:46 cgroup.clone_children--w--w--w- 1 root root 0 1月 3 17:46 cgroup.event_control-rw-r--r-- 1 root root 0 1月 3 17:46 cgroup.procsdrwxr-xr-x 2 root root 0 1月 3 17:50 fea86bf355df7b04e1e4bce4168f042e82a8b18cf395476e0a1e021c6d68cc32/-rw-r--r-- 1 root root 0 1月 3 17:46 memory.failcnt--w------- 1 root root 0 1月 3 17:46 memory.force_empty-rw-r--r-- 1 root root 0 1月 3 17:46 memory.kmem.failcnt-rw-r--r-- 1 root root 0 1月 3 17:46 memory.kmem.limit_in_bytes-rw-r--r-- 1 root root 0 1月 3 17:46 memory.kmem.max_usage_in_bytes-r--r--r-- 1 root root 0 1月 3 17:46 memory.kmem.slabinfo-rw-r--r-- 1 root root 0 1月 3 17:46 memory.kmem.tcp.failcnt-rw-r--r-- 1 root root 0 1月 3 17:46 memory.kmem.tcp.limit_in_bytes-rw-r--r-- 1 root root 0 1月 3 17:46 memory.kmem.tcp.max_usage_in_bytes-r--r--r-- 1 root root 0 1月 3 17:46 memory.kmem.tcp.usage_in_bytes-r--r--r-- 1 root root 0 1月 3 17:46 memory.kmem.usage_in_bytes-rw-r--r-- 1 root root 0 1月 3 17:46 memory.limit_in_bytes-rw-r--r-- 1 root root 0 1月 3 17:46 memory.max_usage_in_bytes-rw-r--r-- 1 root root 0 1月 3 17:46 memory.move_charge_at_immigrate-r--r--r-- 1 root root 0 1月 3 17:46 memory.numa_stat-rw-r--r-- 1 root root 0 1月 3 17:46 memory.oom_control---------- 1 root root 0 1月 3 17:46 memory.pressure_level-rw-r--r-- 1 root root 0 1月 3 17:46 memory.soft_limit_in_bytes-r--r--r-- 1 root root 0 1月 3 17:46 memory.stat-rw-r--r-- 1 root root 0 1月 3 17:46 memory.swappiness-r--r--r-- 1 root root 0 1月 3 17:46 memory.usage_in_bytes-rw-r--r-- 1 root root 0 1月 3 17:46 memory.use_hierarchy-rw-r--r-- 1 root root 0 1月 3 17:46 notify_on_release-rw-r--r-- 1 root root 0 1月 3 17:46 tasks 修改各项配置文件，即可修改各项资源限制的配置 查看某个容器的资源限制 1234567891011121314151617181920212223242526272829303132felix@felix-ubuntu17:/sys/fs/cgroup/memory/docker$ cd fea86bf355df7b04e1e4bce4168f042e82a8b18cf395476e0a1e021c6d68cc32/felix@felix-ubuntu17:/sys/fs/cgroup/memory/docker/fea86bf355df7b04e1e4bce4168f042e82a8b18cf395476e0a1e021c6d68cc32$ lltotal 0drwxr-xr-x 2 root root 0 1月 3 17:50 ./drwxr-xr-x 3 root root 0 1月 3 17:50 ../-rw-r--r-- 1 root root 0 1月 3 17:50 cgroup.clone_children--w--w--w- 1 root root 0 1月 3 17:50 cgroup.event_control-rw-r--r-- 1 root root 0 1月 3 17:50 cgroup.procs-rw-r--r-- 1 root root 0 1月 3 17:50 memory.failcnt--w------- 1 root root 0 1月 3 17:50 memory.force_empty-rw-r--r-- 1 root root 0 1月 3 17:50 memory.kmem.failcnt-rw-r--r-- 1 root root 0 1月 3 17:50 memory.kmem.limit_in_bytes-rw-r--r-- 1 root root 0 1月 3 17:50 memory.kmem.max_usage_in_bytes-r--r--r-- 1 root root 0 1月 3 17:50 memory.kmem.slabinfo-rw-r--r-- 1 root root 0 1月 3 17:50 memory.kmem.tcp.failcnt-rw-r--r-- 1 root root 0 1月 3 17:50 memory.kmem.tcp.limit_in_bytes-rw-r--r-- 1 root root 0 1月 3 17:50 memory.kmem.tcp.max_usage_in_bytes-r--r--r-- 1 root root 0 1月 3 17:50 memory.kmem.tcp.usage_in_bytes-r--r--r-- 1 root root 0 1月 3 17:50 memory.kmem.usage_in_bytes-rw-r--r-- 1 root root 0 1月 3 17:50 memory.limit_in_bytes-rw-r--r-- 1 root root 0 1月 3 17:50 memory.max_usage_in_bytes-rw-r--r-- 1 root root 0 1月 3 17:50 memory.move_charge_at_immigrate-r--r--r-- 1 root root 0 1月 3 17:50 memory.numa_stat-rw-r--r-- 1 root root 0 1月 3 17:50 memory.oom_control---------- 1 root root 0 1月 3 17:50 memory.pressure_level-rw-r--r-- 1 root root 0 1月 3 17:50 memory.soft_limit_in_bytes-r--r--r-- 1 root root 0 1月 3 17:50 memory.stat-rw-r--r-- 1 root root 0 1月 3 17:50 memory.swappiness-r--r--r-- 1 root root 0 1月 3 17:50 memory.usage_in_bytes-rw-r--r-- 1 root root 0 1月 3 17:50 memory.use_hierarchy-rw-r--r-- 1 root root 0 1月 3 17:50 notify_on_release-rw-r--r-- 1 root root 0 1月 3 17:50 tasks 启动容器时对指定的资源限制进行配置 例如： 可以使用启动参数-c | --cpu-shares[=0]来调整使用CPU的优先级 使用-m | memory[=MEMORY]来调整容器使用内存的大小 18.4 联合文件系统UFS 联合文件系统：轻量级的高性能分层文件系统 将文件系统的修改信息作为一次提交，并层层叠加 同时，可将不同目录挂载到同一个虚拟文件系统下 Docker重要的UFS就是AUFS（Another Union File System或者v2版本以后的Advanced Multi-layered Unification File System）。 AUFS： 支持每个成员目录（类似于Git的分支）设定为只读、读写和可写权限。 AUFS里有个类似分层的概念，对制度权限的分支可以逻辑上进行增量的修改（不影响只读部分） 当Docker利用镜像启动一个容器时，将利用镜像分配文件系统，并挂载一个新的可读写层给容器，容器围在这个文件系统中创建，并将这个可读写层添加到镜像中 18.5 Docker网络实现 Docker的网络实现主要利用了Linux网络上的网络命名空间和虚拟网络设备（特别是veth pair） 虚拟网络接口：其最大的优势是转发效率极高。这是因为Linux通过在内核中进行数据复制来实现虚拟接口之间的数据转发。这比通过外部物理网络设备进行交换要快得多。Docker容器网络就是利用了Linux虚拟网络接口。它在本地和容器内分别见了一个虚拟接口，并让它们彼此连通（这样的一堆借口叫做veth pair） 网络创建过程 启动容器时，也可以通过启动参数--net来指定容器的网络配置，可配置的模式有：bridge、host、container、none 网络配置细节：","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第十七章 Docker实践之道","date":"2018-01-02T05:16:58.000Z","path":"2018/01/02/Docker技术入门与实战-第十七章-Docker实践之道/","text":"目前Docker发展迅速，基于Docker的PaaS平台层出不穷 17.1 个人学习之道 温故而知新 快速上手Hello World：这是学习新知识的标准思路：最小系统原则，即从变量最少的最小系统开始，循序渐渐地学习；使用Docker可以将学习前环境部署等时间大幅缩短，将更多的精力放在语言学习本身上 Docker化的代码仓库：Docker化的代码仓库使得很多先验的经验得以保存和复用 面向业务编程：MOP Market/Money Oriented Programming(面向市场或利润编程)是唯一不变的编程范式。因此，Docker可以帮助软件工程师面向业务需求，快速的进行业务的实现了研究，而不在于一些繁琐的重复性配置工作 众人拾柴火焰高 将开源项目放入Docker中进行开发和测试，使得任何参与者能够在统一环境开发/运行/测试 17.2 技术创业之道 DevOps：(Development和Operations的组合)是一组过程、方法和系统的统称，用于在研发、运维、QA团队之间的沟通、协作。 Docker的目的：用于生产团队在研发、运维、QA之间的高效沟通协作 2.1 Docker的优势： 完整地封装系统：包括OS系统、Lib环境、App应用，完整的三层封装 自由地定制系统：包括以上三层的灵活又彻底的自定义 方便地发布系统：包括部署管理，自动化部署 2.2 Docker能解决的问题 更小、更频繁的需求变更 生产环境不受开发人员控制 业务应用程序成为中心，而不是基础设施 定义简洁明了的研发部署流程需要更多成本与时间 研发部署无法彻底自动化 现有PaaS虚拟机难以促成开发与运营的协作 产品的Docker化发布直接使用Docker建设产品的发布流程，不仅可以方便地管理迭代与集成，还可以直接以Docker话的方式发布产品。使得产品的部署十分简单。 17.3 中小型企业实践之道 传统开发流程和Docker开发流程的比较： Docker模式下的开发流程，使得开发、测试、运维三个部门减少了很多重复的工作 应用Docker的开发流程：架构师的作用贯穿整个开发、测试、生产三个环节 项目开始时，架构师根据项目预期，创建好需要的基础Base镜像 所以开发人员根据Dockerfile创建的容器和从内部仓库下载的镜像来进行开发 若开发过程中需要添加新的软件，只需要向架构师申请更改基础的base镜像的Dockerfile 开发结束后，架构师调整Dockerfile或者image，然后分发给测试部门 基于Docker的开发模型： 使用-v共享文件夹来存储开发人员的程序代码 测试部门应当对Docker版本的程序和部署在普通服务器上的额应用程序进行性能测试 应用Docker到生产环境所应当注意的问题：","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第十六章 在公有云上使用Docker","date":"2018-01-01T13:01:52.000Z","path":"2018/01/01/Docker技术入门与实战-第十六章-在公有云上使用Docker/","text":"16.1 公有云上安装Docker 安装前检查内核 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748felix@felix-ubuntu17:~/docker/docker-registry$ lxc-checkconfigKernel configuration not found at /proc/config.gz; searching...Kernel configuration found at /boot/config-4.10.0-19-generic--- Namespaces ---Namespaces: enabledUtsname namespace: enabledIpc namespace: enabledPid namespace: enabledUser namespace: enabledWarning: newuidmap is not setuid-rootWarning: newgidmap is not setuid-rootNetwork namespace: enabled--- Control groups ---Cgroup: enabledCgroup clone_children flag: enabledCgroup device: enabledCgroup sched: enabledCgroup cpu account: enabledCgroup memory controller: enabledCgroup cpuset: enabled--- Misc ---Veth pair device: enabledMacvlan: enabledVlan: enabledBridges: enabledAdvanced netfilter: enabledCONFIG_NF_NAT_IPV4: enabledCONFIG_NF_NAT_IPV6: enabledCONFIG_IP_NF_TARGET_MASQUERADE: enabledCONFIG_IP6_NF_TARGET_MASQUERADE: enabledCONFIG_NETFILTER_XT_TARGET_CHECKSUM: enabledFUSE (for use with lxcfs): enabled--- Checkpoint/Restore ---checkpoint restore: enabledCONFIG_FHANDLE: enabledCONFIG_EVENTFD: enabledCONFIG_EPOLL: enabledCONFIG_UNIX_DIAG: enabledCONFIG_INET_DIAG: enabledCONFIG_PACKET_DIAG: enabledCONFIG_NETLINK_DIAG: enabledFile capabilities: enabledNote : Before booting a new kernel, you can check its configurationusage : CONFIG=/path/to/config /usr/bin/lxc-checkconfig 可以看到Control groups项目在内核中是支持的，如果不支持，请升级内核 安装： CentOS: yum install docker-io Ubuntu: 加docker源，然而sudo apt-get install lxc-docker 启动： service docker start 若启动过程有问题，使用docker -d启动，来查看详细启动过程 启动时，遇到无法分配空闲IP的错误时，可以使用docker --bip 192.168.100.1/24 -d &amp;手动分配 16.2 阿里云Docker的特色服务 阿里云ECS Docker的完整开发-测试-交付生态图 开发-测试-交付生态图 首先，运维人员在公有云上搭建私有Docker注册服务器，以存储项目组镜像 开发人员，从公有或者私有的Docker Registry获取开发基础镜像进行开发；开发完成后，提交镜像到私有的私有的Docker Registry的对应仓库 测试人员，从私有的Docker Registry获取开发人员提交的开发镜像进行测试；测试完成后，测试人员将测试通过的镜像提交至用于发布的私有的Docker Registry 交付人员，从用于发布的私有的Docker Registry直接获取发布产品的镜像 使用阿里云的Docker镜像加速器 登录容器Hub服务 针对Docker客户端版本大于1.10.0的用户,您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器： 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123;\"registry-mirrors\": [\"https://5ce7qk6s.mirror.aliyuncs.com\"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 支持阿里云OSS(对象存储)的私有仓库 docker-registry目前支持将镜像数据存储在S3、GCS、AliyunOSS等云存储上 快速启动支持OSS的docker-registry： sudo docker run -e OSS_BUCKET=&lt;your_ali_oss_bucket&gt; -e STROAGE_PATH=/docker/ -e OSS_KEY=&lt;your_ali_oss_key&gt; -e OSS_SECRET=&lt;your_ali_oss_secret&gt; -p 5000:5000 -d chrisjin/registry:ali_oss 通过下载安装docker-registry 通过pip安装OSS driversudo pip install docker-registry-driver-alioss 配置config.yml 1234567local: &amp;local &lt;&lt;: *common stroage: alioss stroage_path: _env:STROGAE_PATH:/devregistry/ oss_bucket: _env:OSS_BUCKET[:default_value] oss_accessid: _env:OSS_KEY[:your_access_id] oss_accesskey: _env:OSS_SECRET[:your_access_key] 启动docker-registryDOCKER_REGISTRY_CONFIG=[ your_config_path ] gunicron -k gevnet -b 0.0.0.0:5000 -w 1 docker_registry.wi:application 16.3 本章小结通过整合公有云的虚拟机和Docker方式的优势在于： 快速交付和部署 利用内核级虚拟化，对公有云中服务器资源进行更加高效地利用 利用公有云和Docker的特性更加方便的迁移和扩展应用","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第十五章 构建Docker容器集群","date":"2018-01-01T07:29:45.000Z","path":"2018/01/01/Docker技术入门与实战-第十五章-构建Docker容器集群/","text":"Docker的网络模式概述自从docker容器出现以来，容器的网络通信就一直是大家关注的焦点，也是生产环境的迫切需求。而容器的网络通信又可以分为两大方面：单主机容器上的相互通信和跨主机的容器相互通信。而本文将分别针对这两方面，对容器的通信原理进行简单的分析。 docker单主机容器通信基于对net namespace的控制，docker可以为在容器创建隔离的网络环境，在隔离的网络环境下，容器具有完全独立的网络栈，与宿主机隔离，也可以使容器共享主机或者其他容器的网络命名空间，基本可以满足开发者在各种场景下的需要。按docker官方的说法，docker容器的网络有五种模式： bridge：docker默认的网络模式，为容器创建独立的网络命名空间，容器具有独立的网卡等所有单独的网络栈，是最常用的使用方式。 host：直接使用容器宿主机的网络命名空间。 none：为容器创建独立网络命名空间，但不为它做任何网络配置，容器中只有lo，用户可以在此基础上，对容器网络做任意定制。 其他容器：与host模式类似，只是容器将与指定的容器共享网络命名空间。 用户自定义：docker 1.9版本以后新增的特性，允许容器使用第三方的网络实现或者创建单独的bridge网络，提供网络隔离能力。 这些网络模式在相互网络通信方面的对比如下所示： 模式 是否支持多主机 南北向通信机制东西向通信机制 bridge 否 宿主机端口绑定 通过Linux bridgehost 是 按宿主机网络通信 按宿主机网络通信none 否 无法通信 只能用link通信其他容器 否 宿主机端口绑定 通过link通信用户自定义 按网络实现而定 按网络实现而定 按网络实现而定南北向通信指容器与宿主机外界的访问机制，东西向流量指同一宿主机上与其他容器相互访问的机制。 host模式由于容器和宿主机共享同一个网络命名空间，换言之，容器的IP地址即为宿主机的IP地址。所以容器可以和宿主机一样，使用宿主机的任意网卡，实现和外界的通信。其网络模型可以参照下图： ch15.0-1 采用host模式的容器，可以直接使用宿主机的IP地址与外界进行通信，若宿主机具有公有IP，那么容器也拥有这个公有IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行NAT转换，而且由于容器通信时，不再需要通过linuxbridge等方式转发或者数据包的拆封，性能上有很大优势。当然，这种模式有优势，也就有劣势，主要包括以下几个方面： 最明显的就是容器不再拥有隔离、独立的网络栈。容器会与宿主机竞争网络栈的使用，并且容器的崩溃就可能导致宿主机崩溃，在生产环境中，这种问题可能是不被允许的。容器内部将不再拥有所有的端口资源，因为一些端口已经被宿主机服务、bridge模式的容器端口绑定等其他服务占用掉了。 bridge模式bridge模式是docker默认的，也是开发者最常使用的网络模式。在这种模式下，docker为容器创建独立的网络栈，保证容器内的进程使用独立的网络环境，实现容器之间、容器与宿主机之间的网络栈隔离。同时，通过宿主机上的docker0网桥，容器可以与宿主机乃至外界进行网络通信。其网络模型可以参考下图： ch15.0-2 从该网络模型可以看出，容器从原理上是可以与宿主机乃至外界的其他机器通信的。同一宿主机上，容器之间都是连接到docker0这个网桥上的，它可以作为虚拟交换机使容器可以相互通信。然而，由于宿主机的IP地址与容器veth pair的 IP地址均不在同一个网段，故仅仅依靠veth pair和namespace的技术，还不足以使宿主机以外的网络主动发现容器的存在。为了使外界可以方位容器中的进程，docker采用了端口绑定的方式，也就是通过iptables的NAT，将宿主机上的端口端口流量转发到容器内的端口上。 举一个简单的例子，使用下面的命令创建容器，并将宿主机的3306端口绑定到容器的3306端口：1docker run -tid –name db -p 3306:3306 MySQL 在宿主机上，可以通过iptables -t nat -L -n，查到一条DNAT规则：1DNAT tcp — 0.0.0.0/0 0.0.0.0/0 tcp dpt:3306 to:172.17.0.5:3306 上面的172.17.0.5即为bridge模式下，创建的容器IP。 很明显，bridge模式的容器与外界通信时，必定会占用宿主机上的端口，从而与宿主机竞争端口资源，对宿主机端口的管理会是一个比较大的问题。同时，由于容器与外界通信是基于三层上iptables NAT，性能和效率上的损耗是可以预见的。 none模式在这种模式下，容器有独立的网络栈，但不包含任何网络配置，只具有lo这个loopback网卡用于进程通信。也就是说，none模式为容器做了最少的网络设置，但是俗话说得好“少即是多”，在没有网络配置的情况下，通过第三方工具或者手工的方式，开发这任意定制容器的网络，提供了最高的灵活性。 其他容器模式其他网络模式是docker中一种较为特别的网络的模式。在这个模式下的容器，会使用其他容器的网络命名空间，其网络隔离性会处于bridge桥接模式与host模式之间。当容器共享其他容器的网络命名空间，则在这两个容器之间不存在网络隔离，而她们又与宿主机以及除此之外其他的容器存在网络隔离。其网络模型可以参考下图： ch15.0-3 在这种模式下的容器可以通过localhost来同一网络命名空间下的其他容器，传输效率较高。而且这种模式还节约了一定数量的网络资源，但它并没有改变容器与外界通信的方式。在一些特殊的场景中非常有用，例如，kubernetes的pod，kubernetes为pod创建一个基础设施容器，同一pod下的其他容器都以其他容器模式共享这个基础设施容器的网络命名空间，相互之间以localhost访问，构成一个统一的整体。 用户定义网络模式在用户定义网络模式下，开发者可以使用任何docker支持的第三方网络driver来定制容器的网络。并且，docker 1.9以上的版本默认自带了bridge和overlay两种类型的自定义网络driver。可以用于集成calico、weave、openvswitch等第三方厂商的网络实现。 除了docker自带的bridge driver，其他的几种driver都可以实现容器的跨主机通信。而基于bdrige driver的网络，docker会自动为其创建iptables规则，保证与其他网络之间、与docker0之间的网络隔离。例如，使用下面的命令创建一个基于bridge driver的自定义网络： 1docker network create bri1 则docker会自动生成如下的iptables规则，保证不同网络上的容器无法互相通信。 12-A DOCKER-ISOLATION -i br-8dba6df70456 -o docker0 -j DROP-A DOCKER-ISOLATION -i docker0 -o br-8dba6df70456 -j DROP 除此之外，bridge driver的所有行为都和默认的bridge模式完全一致。而overlay及其他driver，则可以实现容器的跨主机通信。 docker跨主机容器通信早期大家的跨主机通信方案主要有以下几种： 容器使用host模式：容器直接使用宿主机的网络，这样天生就可以支持跨主机通信。虽然可以解决跨主机通信问题，但这种方式应用场景很有限，容易出现端口冲突，也无法做到隔离网络环境，一个容器崩溃很可能引起整个宿主机的崩溃。 端口绑定：通过绑定容器端口到宿主机端口，跨主机通信时，使用主机IP+端口的方式访问容器中的服务。显而易见，这种方式仅能支持网络栈的四层及以上的应用，并且容器与宿主机紧耦合，很难灵活的处理，可扩展性不佳。 docker外定制容器网络：在容器通过docker创建完成后，然后再通过修改容器的网络命名空间来定义容器网络。典型的就是很久以前的pipework，容器以none模式创建，pipework通过进入容器的网络命名空间为容器重新配置网络，这样容器网络可以是静态IP、vxlan网络等各种方式，非常灵活，容器启动的一段时间内会没有IP，明显无法在大规模场景下使用，只能在实验室中测试使用。 第三方SDN定义容器网络：使用Open vSwitch或Flannel等第三方SDN工具，为容器构建可以跨主机通信的网络环境。这些方案一般要求各个主机上的docker0网桥的cidr不同，以避免出现IP冲突的问题，限制了容器在宿主机上的可获取IP范围。并且在容器需要对集群外提供服务时，需要比较复杂的配置，对部署实施人员的网络技能要求比较高。 上面这些方案有各种各样的缺陷，同时也因为跨主机通信的迫切需求，docker 1.9版本时，官方提出了基于vxlan的overlay网络实现，原生支持容器的跨主机通信。同时，还支持通过libnetwork的plugin机制扩展各种第三方实现，从而以不同的方式实现跨主机通信。就目前社区比较流行的方案来说，跨主机通信的基本实现方案有以下几种： 基于隧道的overlay网络：按隧道类型来说，不同的公司或者组织有不同的实现方案。docker原生的overlay网络就是基于vxlan隧道实现的。ovn则需要通过geneve或者stt隧道来实现的。flannel最新版本也开始默认基于vxlan实现overlay网络。 基于包封装的overlay网络：基于UDP封装等数据包包装方式，在docker集群上实现跨主机网络。典型实现方案有weave、flannel的早期版本。 基于三层实现SDN网络：基于三层协议和路由，直接在三层上实现跨主机网络，并且通过iptables实现网络的安全隔离。典型的方案为Project Calico。同时对不支持三层路由的环境，Project Calico还提供了基于IPIP封装的跨主机网络实现。 15.1 使用自定义网桥连接跨主机容器 Docker默认的网桥是docker0，它会在本机连接所有的容器 自定义网桥连接到主机容器 2.1 拓扑图 2.2 创建自己的网桥br0,将物理网卡连接到br0上编辑/etc/network/interface文件： 12345678auto br0iface bro inet staticaddress 192.168.2.36netmask 255.255.255.0gateway 192.168.2.1bridge_ports enp0s3brdige_stp offdns-nameservers 8.8.8.8 192.168.2.1 2.3 本地修改/etc/deault/docker文件，在最后一行添加： 1DOCKER_OPTS=&quot;-b=br0&quot; 在启动Docker的时候使用-b参数也可以将容器绑定到指定的网桥br0上 由此，就实现了将容器端口直接暴露到物理网络上，堕胎物理主机的容器通过访问外部映射端口即可相互联网了 15.2 使用Ambassador容器 两个Docker容器在同一主机上时，可以通过--link命令让两者相互访问 当两个Docker容器不在同一个主机上时，要实现互联，则往往需要知道其他物理主机的IP地址。而利用Ambassador容器机制，可以让Ambassador容器作为连接代理，实现跨主机连接 基本场景 原理： 通过两个Ambassador容器来进行通信代理 应用： 创建一个服务端容器redis-serversudo docker run -d --name redis-server crosbymichael/redis 创建一个服务端Ambassador容器redis_ambassadorsudo docker run -d -link redis-server:redis --name redis_ambassador -p 6379:6379 svendowideit/ambassador 客户端主机上创建客户端Ambassador容器sudo docker run -d -name redis_ambassador -expose 6379 -e REDIS_PORT_6379_TCP=tcp://x.x.x.x:6379 svendowideit/ambassador 创建一个客户端容器(默认访问6379端口，实际是访问服务端容器内的redis应用)sudo docker run -it -rm -link redis_ambassador:redis relateiq/redis-cli redis 172.17.0.160:6379&gt; ping 15.3 本章小结 容器的集群管理，主要要实现两个方面的需求： 容器名称的动态管理 需要底层网络提供灵活的跨主机的支持租户隔离的连接 容器名称的动态管理 即使容器重启，容器内的IP发生变化，利用SkyDNS+SkyDock、etcd、consul等工具来实现容器的DNS系统 底层网络提供灵活的连接 使用Overlay技术。事实上，管理虚拟机的OpenStack等项目提供了相对成熟的基于SDN的网络管理方案。 现在已经有包括Shipyard、Kubernetes等项目实现了一整套的容器集群管理方案","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第十四章 使用私有仓库","date":"2018-01-01T05:20:36.000Z","path":"2018/01/01/Docker技术入门与实战-第十四章-使用私有仓库/","text":"14.1 使用docker-registry docker-registry是一个基于Python的开源项目，可以用于构建私有的镜像注册服务 14.1.1 基于容器运行 获取并运行官方registry镜像sudo docker run -d -P registry 指定本地路径(如：/home/user/registry-conf)下的配置文件sudo docker run -d -p 5000:5000 -v /home/user/registry-conf:/registry-conf -e DOCKER_REGISTRY_CONFIG=/registry-conf/config.yml registry 通过-v参数来配置仓库路径sudo docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry 14.1.2 本地安装 通过pip源安装 123$ sudo apt-get install -y build-essential python-dev libevent-dev python-pip liblzma-dev$ sudo pip install gunicorn pyyaml flask flask-core rsa$ sudo pip install docker-registry 通过源码安装 123$ sudo apt-get install -y build-essential python-dev libevent-dev python-pip libssl-dev liblzma-dev libffi-dev$ git clone https://github.com/docker/docker-registry.git$ cd docker-registry 然后基于配置模板创建配置文件： 1$ cp config/config_sample.yml config/config.yml 修改local模板段的storage_path到本地的仓储仓库的路径 1234local: &amp;local &lt;&lt;: *common storage: local storage_path: env:STORGE_PATH:/opt/data/registory 执行安装 1$ sudo python setup.py install 启动程序 1$ sudo gunicorn --access-logfile /var/log/docker-registry/access.log --error-logfile /var/log/docker-registry/server.log -k gevent --max-requests 100 --graceful-timeout 3600 -t 3600 -b 127.0.0.1:15000 -w 1 docker_registry.wsgi:application 将启动命令封装成service 创建/etc/init/docker_registry.conf1234567891011description \"Docker Registry\"start on runlevel [2345]stop on runlevel [016]respawnrespawn limit 10 5scriptexec gunicorn --access-logfile /var/log/docker-registry/access.log --error-logfile /var/log/docker-registry/server.log -k gevent --max-requests 100 --graceful-timeout 3600 -t 3600 -b 127.0.0.1:15000 -w 1 docker_registry.wsgi:applicationend script 启动服务： 1$ service docker-registry start 14.2 用户认证14.2.1 配置Nginx代理 通过Nginx监听对外的5000端口，来转发至registry的15000端口 步骤 2.1 安装Nginx 1$ sudo apt-get install nginx 2.2 nginx配置文件：在/etc/nginx/sites-avaliable/目录下，创建新的站点配置文件/etc/nginx/sites-avaliable/docker-registry.conf 2.3 将配置文件软连接到/etc/nginx/sites-enable/下面 12$ sudo ln -s /etc/nginx/sites-avaliable/docker-registry.conf /etc/nginx/sites-enable/docker-registry.conf$ service nginx restart 2.4 上传镜像测试 12$ sudo docker tag ubuntu:14.04 127.0.0.1:5000/ubuntu:latest$ sudo docker push 127.0.0.1:5000/ubuntu:latest 14.2.2 添加用户认证 DockerHub采用注册索引index服务来实现，但是index服务并没有开源，所有可以使用基于nginx代理的用户访问管理 修改nigix配置文件，在配置文件中增加： auth_basic &quot;Please Input username/password&quot;:说明启用认证服务，不通过的请求无法转发 auth_basic_user_file docker-registry-htpasswd:指定了验证的用户名和密码存储文件为本地(/etc/nginx下)的docker-registry-htpasswd docker-registry-htpasswd文件存储的用户名/密码格式为如下： 123user1: password1user2: password2... 存储的不是明文，而是crypt函数加密过的字符串。要生成这样的加密用户/密码，可以使用htpasswd工具生成 安装apache2-utils：sudo apt-get install apache2-utils -y 生成用户名/密码: 1234$ sudo htpasswd -c /etc/nginx/docker-registry-htpasswd user1$ New password:$ Re-type new password:$ Adding password for user user1 重启服务：sudo servcie nginx restart 14.3 使用私有仓库批量上传镜像 利用push_images.sh脚本，批量上传镜像到指定仓库 push_images.sh脚本 使用： 1$ ./push_images.sh ubuntu:latest centos:centos7 利用push_all.sh脚本，批量上传所有镜像到指定仓库 push_all.sh脚本 14.4 仓库配置文件 Docker的Registry提供了配置的模板文件/docker-registry/config/config_sample.yml，利用配置文件提供了一下仓库的模板，可以根据这些模板来进行开发和生产部署 Configuration Reference: Configuration mechanism overview","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第十三章 编程语言","date":"2017-12-30T12:33:45.000Z","path":"2017/12/30/Docker技术入门与实战-第十三章-编程语言/","text":"13.1 PHP php是一种动态脚本语言。 优点：随着网站的PV/UV的增长，需要支持更大的并发的时候，基于原有的PHP系统进行分层优化和业务整合相对容易。 php的哲学是quick and dirty(快速有效为先)，十分适合对交付速度要求很高的场景 使用官方镜像 Dockerfile 123456FROM php:latestCOPY myapp.php /usr/src/app/myapp.phpWORKDIR /usr/src/appCMD [\"php\",\"./myapp.php\"] 创建镜像 sudo docker build -t my-php-app . 创建容器 sudo docker run -it --rm --name my-running-app my-php-app /bin/bash 使用带有Apache的php镜像 Dockerfile 12345FROM php:5.6-apache#拷贝php的配置文件COPY config/php.ini /usr/local/lib/#拷贝源码文件COPY src/ /var/www/html/ PHP常用框架 4.1 CakePHP 特性：Rails风格的开源全栈MVC框架（此处的全栈是相对于Yaf这类微框架而言的） 下载镜像 sudo docker pull vcarl/cakephp 运行容器 sudo docker run -d -p 80:80 -p 443:443 -v /path/to/project:/var/www/html vcarl/cakephp /path/to/project指向项目根目录 4.2 Zend 特性：用100%面向对象编码实现。每个组件几乎不依靠其他组件，这样松耦合的结构可以让开发者独立使用各种组件 下载Zend Server镜像 sudo docker pull php-zendserver 运行容器 sudo docker run php-zendserver 如果对php和Zend Server的版本有要求，可以在docker run命令中加入 :&lt;php-version&gt;或者:&lt;ZS-version&gt;-php&lt;version&gt;。例如php-zendserver:7.0-php5.4 4.3 Symfony 特性：以依赖注入为核心的全栈式PHP MVC开发框架。以依赖注入的方式为开发者提供了几乎无限的扩展性 下载Symfony镜像 sudo docker pull gregory90/php-symfony 或者sudo docker pull teamrock/sysfony2 4.4 Phalcon 特性：使用C扩展开发的PHP Web框架，具有高性能和低资源占用的特性 开源 全栈的PHP 5框架 使用C扩展，专门为高性能优化，是PHP MVC框架中性能最高的全栈框架 无需学习C语言，所有函数都以PHP类的方式封装 下载Phalcon镜像 sudo docker pull szeist/phalcon-apache2 运行容器 sudo docker run -v /docment/root/on/your/machine:/var/www -p 8080:80 szeist/phalcon-apache2 13.2 C/C++ GCC 1.1 特性： 一个开源的C/C++语言编译器系统 支持多种编程语言 支持交叉编译至多种指令集的处理器 1.2 C/C++代码运行在容器中 就是将GCC编译指令写入Dockerfile中，然后使用此Dockerfile构建自定义镜像，最后直接运行此镜像，即可启动程序 Docerfile 12345FROM gcc:4.9COPY helloworld.c /usr/src/myappWORKDIR /usr/src/myappRUN gcc -o helloworld helloworld.cCMD [\"./helloworld\"] 启动容器时编译/运行C/C++代码 sudo docker run -rm -v &quot;$(pwd)&quot;:/usr/src/myapp -w /usr/src/myapp gcc4.9 gcc -o hellowrold hellowrold.c -w：指定workdir 如果项目已经写好了makefile，也可以在容器中直接执行make:sudo docker run -rm -v &quot;$(pwd)&quot;:/usr/src/myapp -w /usr/src/myapp gcc4.9 make LLVM 2.1 特性 LLVM（Low Level Virtual Machine）的目的是对任意编程语言实现的程序，利用虚拟技术，创造出编译时期、链接时期、运行事情、闲置时期的优化 以C++实现 支持Java bytecode、Objective-C、Python、Ruby、C#等语言 2.2 官方镜像 sudo docker pull imiell/llvm Clang 3.1 特性 基于C++和LLVM实现的C/C++/Objective-C/Objective-C++的编译器 快：Clang比GCC快数倍 内存占用小：Clang内存占用约是源码的1.3倍，而Apple GCC则超过10倍 诊断信息可读性强： 良好兼容GCC 各个功能基于库的模块化设计： GCC是一个单一的可执行程序编译器，内部完成了从预处理到最后代码生成的全部过程，中间的信息都无法被其他程序重用 Clang将编译过程分离成各个单独的库，各个阶段的信息都可以通过库的调用实现重用，例如：可将编译和语法检查的各种信息供IDE的代码补全、提示功能使用 3.2 使用官方镜像 sudo docer pull bowery/clang 13.3 Java 使用官方镜像： sudo docker pull java 定制镜像 2.1 Dockerfile 12345FROM java:7COPY Main.java /usr/src/myappWORKDIR /usr/src/myappRUN javac Main.javaCMD [\"java\",\"Main\"] 2.2 创建镜像 sudo docker build -t my-java-app 2.3 运行容器 sudo docker run -it --rm --name my-running-app my-java-app 13.4 Python 特性： 解释型的、带CLI交互接口的、面向对象的、开源的动态脚本语言 集成了模块(modules)、异常处理(exceptions)、动态类型(dynamic typing)、高级数据结构(元组、列表、序列)、类等高级特性 Python与C/C++代码之间可以方便的相互调用 非常适合敏捷Web开发 Docker中运行Python 2.1 使用官方镜像 sudo docker pull python 2.2 定制镜像(Dockerfile) 123#指定python版本FROM python:2-onbuild#CMD [\"python\",\"./your-daemon-or-script.py\"] 2.3 运行单个Python脚本 sduo docker run -it --rm --name my-running-script -v &quot;$(pwd)&quot;:/usr/src/myapp -w /usr/src/myapp python:3 python your-daemon-or-script.py 一定要指定Python的运行版本 Python的常见框架 3.1 Flask 特性：轻量的Web应用框架;它只有一个简单的核心，使用extension来扩展其他功能 3.2 Django 开源MVC模式的web框架 注重组件的重用性和“可插拔性”，敏捷开发和DRY法则(Don’t Repeat Yourself) 使用官方镜像： sudo docker pull dockerfiles/django-uwsgi-nginx:选用Django、uWSGI and Nginx的技术组合 13.5 Perl 特性： Perl是一个高级的动态解释型的脚本语言 最重要的特性是它内部集成了正则表达式的功能，以及巨大的第三方代码库CPAN 官方镜像 sudo docker pull perl Catalyst Catalyst是一个Perl语言开发的MVC框架 13.6 Ruby 特性： 一种跨平台、面向对象、通用的开源动态脚本语言 支持多种编程范式： 函数编程 面向对象变成 CLI交互编程 动态数据类型 自动内存管理 使用官方镜像 sudo docker pull ruby Ruby框架 3.1 JRuby:类似于Python的Jython，可在Java上运行Ruby语言 3.2 Ruby on Rails Ruby语言写的网页程序开发框架 一些设计理念和机制比较创新，比较彻底的实现了面向对象编程 3.3 Sinatra 比较优雅的包装了Web开发的DSL（领域特定语言），用Sinatra只需5行代码即可实现一个helloword程序： 123456require 'rubygems'require 'sinatra'get '/' do 'hello world'end 13.7 JavaScript JavaScript技术栈 一种弱类型的解释型动态脚本语言 支持面向对象变成 浏览器默认自带JavaScript解释器 重复利用JavaScript MVC框架的优势，将敏捷开发发挥到极致 JavaScript解释器也可运行于后端时，JavaScript也支持后端开发。比如Node.js Node.js JavaScript代码通过V8引擎运行于后端服务器。 它的并发能力与PHP、Python等相当 Node.js的Web框架-Express 目前最稳定、最广泛使用的Node.js的Web框架 Express不对Node.js已有的特性进行二次抽象，而只是在其之上扩展了Web应用所需的功能 AngularJS 是一个JavaScript MVC框架，AngularJS很小，只有60k 特性： 数据绑定 模板 MVC 依赖注入 指令 13.8 Go(Golang) 基本设计理念：编译效率、运行效率、开发效率三者兼顾（Python的便利，C++的运行效率，小到可以忽略的编译时间） 特性： 静态类型：满足运行效率要求 自动垃圾回收 简洁的符号和语法 平坦的类型系统：使用结构化类型系统，简化事前设计，也为未来增加抽象层提供了非侵入式的解决方法 基于CSP模型的并行：使用比线程更轻量的goroutime，让一个线程可以执行多个并发结构，简化了并发结构的通信和数据共享 使用一套简单规范，简化依赖和编译流程 Go框架： 3.1 Beego：使用Go的思维来帮助开发者构建并开发Go应用程序的开源框架 3.2 Revel：高生产力的轻量级的Web开发框架 3.3 Martini：优雅的Go语言Web框架，专为编写模块化的Web应用而生 13.9 本章小结 使用Docker搭建各种编程语言及其常用开发框架的Docker环境的方法一般分两种： 基于内含SSH服务的镜像，定制Dockerfile。随后构建并运行镜像： 优点：可以方便的使用SSH服务访问自定义容器中的站点或程序 直接使用官方的编程语言镜像，然后通过适当的配置也可以构建自定义的镜像","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第十二章 数据库应用","date":"2017-12-30T09:07:43.000Z","path":"2017/12/30/Docker技术入门与实战-第十二章-数据库应用/","text":"关系型数据库：建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据，支持复杂的事务处理和结构化查询 非关系型数据库：放弃了传统关系型数据库的强一致性的限制，使其更适用于大规模的并行处理的生产环境，并能在这些场景中发挥出优异的性能 12.1 MySQL 下载Dockerpool社区的mysql镜像的项目： git clone https://github.com/DockerPool/mysql.git 里面包含了Dockerfile、create_db.sh、import_sql.sh、my.cnf、mysqld_charset.cnf、run.sh等脚本和配置文件 Dockerfile 12345678910111213141516171819202122232425262728293031323334353637#本文参考了「tutum」的 DockerfileFROM sshdMAINTAINER Waitfish &lt;dwj_zz@163.com&gt;#安装软件 ENV DEBIAN_FRONTEND noninteractiveRUN apt-get update &amp;&amp; \\apt-get -yq install mysql-server-5.6 pwgen &amp;&amp; \\rm -rf /var/lib/apt/lists/*# 删除预安装的数据库文件RUN rm -rf /var/lib/mysql/*# 添加文件夹下的 MYSQL 配置文件ADD my.cnf /etc/mysql/conf.d/my.cnfADD mysqld_charset.cnf /etc/mysql/conf.d/mysqld_charset.cnf# 添加 MYSQL 的脚本ADD import_sql.sh /import_sql.shADD run.sh /run.shRUN chmod 755 /*.sh# 设置环境变量，用户名以及秘密ENV MYSQL_USER adminENV MYSQL_PASS **Random**# 设置主从复制模式下的环境变量ENV REPLICATION_MASTER **False**ENV REPLICATION_SLAVE **False**ENV REPLICATION_USER replicaENV REPLICATION_PASS replica# 设置可以允许挂载的卷，可以用来备份数据库和配置文件VOLUME [\"/etc/mysql\", \"/var/lib/mysql\"]# 设置可以映射的端口，如果是从我们的 sshd 镜像继承的话，默认还会开启 22 端口EXPOSE 3306CMD [\"/run.sh\"] 创建镜像： sudo docker build -t mysql:latest . 创建容器： sudo docker run -d -P mysql 连接MySQL： 通过SSH进入容器后，利用sql脚本查询MySQL自动创建的root用户和随机创建的root用户密码 mysql &gt; select host, user, password form mysql.user 也可以在启动容器时，指定用户密码： sudo docker run -d -P -e MYSQL_PASS=&quot;mypassword&quot; mysql 挂载目录到MySQL 默认情况下，数据库文件和日志文件都会存在容器的AUFS文件层，而这将会造成 容器便器越来越臃肿，不便于迁移、备份等管理 数据库的性能也会受影响 解决方案是：将数据文件和日志文件都放到指定的本地主机的目录下 sudo docker run -d -P -v /opt/mysqldb:/var/lib/mysql mysql 启用Mysql主从模式 主从模式： 原理： 从库生成两个线程，一个I/O线程，一个SQL线程； i/o线程去请求主库 的binlog，并将得到的binlog日志写到relay log（中继日志） 文件中； 主库会生成一个 log dump 线程，用来给从库 i/o线程传binlog； SQL 线程，会读取relay log文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致； 用途： 实时灾备，用于故障切换 读写分离，提供查询服务 备份，避免影响业务 启动容器时启动主从模式： 启动mysql主容器： sudo docker run -d -e REPLICATION_MASTER=true -P --name mysql mysql:latest mysql主容器的名字必须为mysql，否则会有错误Cannot configure slave, please link it to another MySQL container with alias as &#39;mysql&#39; 启动mysql从容器 sudo docker run -d -e REPLICATION_MASTER=true -P --link mysql:mysql --name mysqlClient mysql:latest Reference: mysql 主从复制原理 12.2 Oracle XE Oracle快捷版(Oracle XE)是一款基于Oracle 11g第二版代码库的小型入门级数据库 Oracle XE限制用户最多存储11GB的用户数据，同时最多使用1GB内存和主机上的一个CPU 安装Oracle XE镜像 sudo docker run -d -P wnameless/oracle-xe-11g 镜像的默认用户名为root,密码为admin Oracle XE默认参数： 123456hostname: localhostport: 49161sid: xeusername: systempassword: oraclePassword for SYS 12.3 MongoDB MongoDB采用C++开发，支持复杂的数据类型和强大的查询语言 自定义MongoDB镜像： 2.1 下载Dockerpool社区的MongoDB镜像的项目： git clone https://github.com/DockerPool/Mongodb.git 里面包含了Dockerfile、set_mongodb_password.sh、run.sh等脚本和配置文件 2.2 Dockerfile 1234567891011121314151617181920212223242526FROM sshdMAINTAINER waitfish from dockerpool.com(dwj_zz@163.com)RUN apt-get update &amp;&amp; \\apt-get install -y mongodb-org &amp;&amp; \\apt-get clean &amp;&amp; \\rm -rf /var/lib/apt/lists/*#创建mongodb存放数据文件的文件夹RUN mkdir -p /data/dbVOLUME /data/db #创建一个可以从本地主机或其他容器挂载的**挂载点**ENV AUTH yes# Add run scripts# set_mongodb_password.sh 主要负责配置数据库的用户名和密码ADD run.sh /run.shADD set_mongodb_password.sh /set_mongodb_password.shRUN chmod 755 ./*.shEXPOSE 27017EXPOSE 28017# run.sh 是启动脚本CMD [\"/run.sh\"] 2.3 set_mongodb_password.sh, run.sh根据配置需要自定义，此处不再赘述 12.4 本章小结 Docker容器中运行用于生产的Oracle数据库不是十分合适,原因有如下几个方面： Oracle作为一个大型的企业级数据库，对运行环境的要求十分苛刻，需要在操作系统内核，网络等多方面进行调整来达到最优化的性能，而这些方面都不是Docker的强项 Oracle数据库拥有自己笨非常完善的集群软件，包括Clusterware、ASM、Dataguard等组件，来保证性能和可用性，这方面Docker还没有较好的支持 Docker技术目前还不在Oracle公司支持的操作系统列表中，无法得到Oracle公司完善的技术支持。","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第十一章 Web服务器应用","date":"2017-12-27T11:22:55.000Z","path":"2017/12/27/Docker技术入门与实战-第十一章-Web服务器应用/","text":"11.1 Apache 创建Dockerfile Dockerfile 12345678910111213141516171819#设置基础镜像FROM sshd:ubuntufile#提供作者信息MAINTAINER from si by Felix (salsa2010@foxmail.com)#安装apache2RUN apt-get -yq install apache2RUN /etc/init.d/apache2 restart#复制启动脚本ADD run.sh /root/run.shRUN chmod 777 /root/*.sh#暴露80端口EXPOSE 80#启动时执行脚本CMD [\"/root/run.sh\"] run.sh 123#/bin/bashservice ssh restart/etc/init.d/apache2 restart 创建apache:ubuntu镜像 sudo docker build -t apache:ubuntu . 启动容器 端口映射 sudo docker run -it -p 10022:22 -p 8080:80 --name apacheUbuntu apache:ubuntufile /bin/bash 使用Dockerfile创建镜像是，子镜像会继承父镜像的开放端口(EXPOSE)；但却不会继承启动命令(CMD) 映射本地目录 sudo docker run -it -p 10022:22 -p 8080:80 - v /home/felix/www:/var/www:ro --name apacheUbuntu apache:ubuntufile /bin/bash 11.2 Nginx Nginx是一款高性能的web服务器和反向代理器 作为web服务器：相比Apache，Nginx使用更少的资源；C语言实现，轻松支持高达50000个并发连接数的响应 可以作为HTTP代理服务器对外进行服务 Dockerfile Tengine镜像：Nginx的增强版 Dockerfile 11.3 Tomcat Dockerfile 12345678910111213141516171819202122232425262728293031323334353637#设置基础镜像FROM sshd:ubuntufile#提供作者信息MAINTAINER from si by Felix (salsa2010@foxmail.com)#设置环境变量ENV DEBIAN_FRONTEND noninteractive#更改系统时区，因为web应用中经常会用到时区这个系统变量，ubuntu默认的时区会有问题#RUN echo \"Asia/Shanghai\" &gt; /etc/timezone &amp;&amp; \\# dpkg-reconfigure -f noninteractive tzdata#安装跟Tomcat用户认证相关的软件RUN apt-get install -yq wget pwgen ca-certificates &amp;&amp; \\ apt-get clean &amp;&amp;\\ rm -rf /var/lib/apt/lists/*#设置Tomcat的环境变量ENV CATALINA_HOME /tomcatENV JAVA_HOME /jdk#复制tomcat和jdk文件到镜像中ADD apache-tomcat-8.5.24 /tomcatADD jdk1.8.0_151 /jdk#复制启动脚本ADD create_tomcat_admin_user.sh /create_tomcat_admin_user.shADD run.sh /run.shRUN chmod +x /*.shRUN chmod +x /tomcat/bin/*.sh#暴露端口EXPOSE 8080#执行启动脚本CMD [\"/run.sh\"] create_tomcat_admin_user.sh 12345678910111213141516171819202122232425262728#/bin/bashif [ ! -f /.tomcat_admin_created ]; then echo \"Tomcat 'admin' user already created\" exit 0fi#generate passwordPASS=$( [ &#123;TOMCAT_PASS&#125; ] &amp;&amp; echo \"preset\" || echo \"random\")echo \"=&gt; Creating and admin user with a $&#123;_word&#125; password in Tomcat\"sed -i -r 's/&lt;\\/tomcat-users&gt;//' $&#123;CATALINA_HOME&#125;/conf/tomcat-users.xmlecho '&lt;role rolename=\"manager-gui\"/&gt;' &gt;&gt; $&#123;CATALINA_HOME&#125;/conf/tomcat-users.xmlecho '&lt;role rolename=\"manager-script\"/&gt;' &gt;&gt; $&#123;CATALINA_HOME&#125;/conf/tomcat-users.xmlecho '&lt;role rolename=\"manager-jmx\"/&gt;' &gt;&gt; $&#123;CATALINA_HOME&#125;/conf/tomcat-users.xmlecho '&lt;role rolename=\"admin-gui\"/&gt;' &gt;&gt; $&#123;CATALINA_HOME&#125;/conf/tomcat-users.xmlecho '&lt;role rolename=\"admin-script\"/&gt;' &gt;&gt; $&#123;CATALINA_HOME&#125;/conf/tomcat-users.xmlecho \"&lt;user username=\\\"admin\\\" password=\\\"$&#123;PASS&#125;\\\"&gt; roles=\\\"manager-gui, manager-script, manager-jmx, admin-gui, admin-script\\\"/&gt;\" &gt;&gt; $&#123;CATALINA_HOME&#125;/conf/tomcat-users.xmlecho '&lt;/tomcat-users&gt;' &gt;&gt; $&#123;CATALINA_HOME&#125;/conf/tomcat-users.xmlecho \"=&gt; Done!\"touch /.tomcat_admin_createdecho \"=================================================\"echo \"You can noew configure to this Tomcat server using:\"echo \"\"echo \" admin:$&#123;PASS&#125;\"echo \"\"echo \"=================================================\" run.sh 1234567#/bin/bashif [ ! -f /.tomcat_admin_created ]; then /create_tomcat_admin_user.shfi/usr/sbin/sshd -D &amp;exec $&#123;CATALINA_HOME&#125;/bin/catalina.sh run 11.4 Weblogic 简介： Weblogic是一个基于JavaEE的中间件 与Tomcat不同的是，Weblogic是一个商业软件 中间件：中间件(middleware)是基础软件的一大类，属于可复用软件的范畴。顾名思义，中间件处于操作系统软件与用户的应用软件的中间。中间件在操作系统、网络和数据库之上，应用软件的下层，总的作用是为处于自己上层的应用软件提供运行与开发的环境，帮助用户灵活、高效地开发和集成复杂的应用软件。在众多关于中间件的定义中，比较普遍被接受的是IDC表述的：中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网络通信。 Weblogic基本概念 Weblogic域：Weblogic域是作为单元进行管理的一组相关的Weblogic服务器资源。一个域包括： 一个或多个Weblogic服务器实例,这些实例可以是： 集群实例 非集群实例 集群与非集群实例 部署在域中的应用程序组件： 此域中的这些应用程序组件和服务实例所需要的资源和服务（包括网络，连接器等） Administration服务器：一个特殊的Weblogic服务器实例，用于用户配置\\管理域中所有资源的核心 Managed服务器：驾驭域中的其他实例为Managed服务器,所有的Web应用、EJB、Web服务和其他资源都在这些服务器上 当安装和部署方式较为复杂时： 可先启动容器，在容器内进行安装和配置 然后，通过docker commit将这个容器提交为一个镜像 最后，再进一步使用Dockerfile来完成最终的镜像创建 具体安装步骤不再赘述 11.5 LAMP LAMP是指：Linux + Apache HTTP Server + MySQL + PHP 通过Dockerfile创建部署自己的PHP应用 Dockerfile 1234FROM tutum/lamp:latestRUN rm -rf /app &amp;&amp; git clone https://github.com/username.customapp.git /appEXPOSE 80 3306CMD [\"run.sh\"] 创建镜像 sudo docker build -t dockerpool/lamp-with-my-app 11.6 CMS CMS: 内容管理系统是指提供内容编辑服务的平台程序 主要的CMS系统： WordPress Drupal Joomla Typo3 … 11.7 本章小结 Docker暂时不支持在容器运行时修改容器的一些配置。比如： 无法为运行中的容器映射更多的宿主主机目录 无法为运行中的主机映射更多宿主主机的网络 … 对于程序代码、程序的资源目录、日志、数据库文件等需要实时更新的数据一顶要通过-v参数映射到宿主主机目录中来，使用Docker的AUFS文件格式，会产生较大的性能问题","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第十章 创建支持SSH服务的镜像","date":"2017-12-27T02:32:22.000Z","path":"2017/12/27/Docker技术入门与实战-第十章-创建支持SSH服务的镜像/","text":"进入容器可以在Host主机上使用attach、exec等命令 通过SSH服务能解决远程管理容器的问题 两种创建容器的方法： docker commit 基于Dockerfile创建 10.1 基于commit命令创建 安装openssh-server 修改root用户密码 辑配置文件/etc/ssh/sshd_config，允许以 root 用户通过 ssh 登录： 1234sudo vi /etc/ssh/sshd_config找到：PermitRootLogin prohibit-password禁用添加：PermitRootLogin yessudo service ssh restart 启动SSH servcie exit，退出容器 保存镜像:sudo docker commit newImageName repoName:Tag sudo docker commit sshunbuntu sshd:ubuntu 使用镜像：sudo docker run -p 10022:22 -d sshd:ubuntu /otherScript.sh 在其他主机登陆docker：sudo ssh root@127.0.0.1 -p 10022 10.2 使用Dockerfile创建 编写Dockerfile 12345678910111213141516171819#设置基础镜像FROM ubuntu:latest#提供作者信息MAINTAINER from Si by Felix(qing.song@si.com)#安装ssh服务RUN apt-get updateRUN apt-get install -y openssh-server#加载Host主机的ssh公钥，便于ssh登陆RUN mkdir -p /root/.sshADD authorized_keys /root/.ssh/authorized_keys#启动ssh服务RUN service ssh start#暴露22号端口EXPOSE 22 创建镜像 sudo docker build -t sshd:ubuntu 运行容器 sudo docker run -d -p 10022:22 sshd:ubuntu","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第九章 操作系统","date":"2017-12-27T02:11:16.000Z","path":"2017/12/27/Docker技术入门与实战-第九章-操作系统/","text":"9.1 Busybox(镜像) Busybox是一个集成了一百多个常用Linux命令和工具的软件工具箱 Busybox可运行于多款POSIX环境的操作系统中 9.2 Debian/Ubuntu Docker镜像为了精简镜像容量，默认删除了很多命令和工具，需要使用apt-get update，然后安装所需工具 9.3 CentOS/Fedora CentOS/Fedora都是基于Redhat的Linux发行版 CentOS是企业级服务器的常用选型 Fedora主要面向个人用户 9.4 CoreOS CoreOS是一个基于Docker的Linux发行版 9.5 本章小结 几乎所有带官方标志的操作系统都无法直接使用用户名和密码直接登录，而且一般都没有安装SSH服务","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第八章 使用Dockerfile创建镜像","date":"2017-12-26T08:26:59.000Z","path":"2017/12/26/Docker技术入门与实战-第八章-使用Dockerfile创建镜像/","text":"Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速的创建自定义的镜像 8.1 基本结构 Dockerfile分为四部分： 基础镜像信息：FROM 维护者信息：MAINTAINER 镜像操作指令：RUN 容器启动时执行指令:CMD 例如： 每运行一个RUN指令，镜像添加新的一层，并提交 8.2 指令 2.1 FROM FROM &lt;image&gt;或FROM &lt;image&gt;:&lt;tag&gt; 第一条指令必须为FROM 同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令 2.2 MAINTAINER MAINTAINER &lt;name&gt; 2.3 RUN RUN &lt;command&gt;：在shell终端中执行命令 RUN [&quot;executable&quot;,&quot;parm1&quot;,&quot;parm2&quot;]：使用exec执行 eg：RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]：指定其他终端执行 当命令较长时，使用\\来换行 2.4 CMD 三种格式： CMD [&quot;executable&quot;,&quot;parm1&quot;,&quot;parm2&quot;]：使用exec执行，推荐方式 CMD command param1 param2：在/bin/sh中执行 CMD [&quot;parm1&quot;,&quot;parm2&quot;]：提供给ENTRYPOINT的默认参数 每个Dockerfile只能有一条CMD命令；如果指定了多条命令，只有最后一条会被执行 启动容器的时候指定了运行的命令，则会覆盖掉CMD指定的命令 2.5 EXPOSE EXPOSE &lt;port&gt; [&lt;port&gt;...] 使用-P和-p标记在启动容器时，暴露该处指定的端口 2.6 ENV 格式：ENV &lt;key&gt; &lt;value&gt; 指定一个环境变量，会被后续RUN指令使用，并在容器运行时保持 例如： 2.7 ADD 格式：ADD &lt;src&gt; &lt;dest&gt; 复制指定的&lt;src&gt;到容器中的&lt;dest&gt; 其中，&lt;src&gt;可以是Dockerfile所在目录的一个相对路径；可以是一个URL，可以是一个tar文件（自动解压为一个目录） 2.8 COPY 格式：COPY &lt;src&gt; &lt;dest&gt; 复制本地主机的&lt;src&gt;（Dockerfile所在目录的一个相对路径）到容器中的&lt;dest&gt; 2.9 ENTRYPOINT 两种格式： ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] ENTRYPOINT command param1 param2(shell中执行) 配置容器启动后执行的命令，并且不可被docker run提供的参数覆盖 每个Dockerfile中只能有一个ENTRYPOINT，当指定多个ENTRYPOINT时，只有最后一个生效 2.10 VOLUME 格式：VOLUME [&quot;/data&quot;] 创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等 2.11 USER 格式：USER daemon 指定运行容器时的用户名或UID，后续的RUN也会使用指定用户 当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可在之前创建所需要的用户，例如： RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres 要临时获取管理员权限可以使用gosu，而不推荐sudo 2.12 WORKDIR 格式：WORKDIR /path/to/workdir 为后续的RUN、CMD、ENTRYPOINT指令配置工作目录 使用多个WORKDIR指令，后续的命令如果参数是相对路径，则会基于之前命令指定路径，例如： 1234WORKDIR /aWORKDIR bWORKDIR c## 最终路径为/a/b/c 2.13 ONBUILD 格式：ONBUILD [INSTRUCTION] 配置当所创建的镜像作为其他新创建镜像的基础镜像时，所执行的操作指令 例子： image-A的Dockerfile 1234[...]ONBUILD ADD . /app/srcONBUILD RUN /usr/local/bin/python-build --dir /app/src[...] 如果基于image-A创建新的镜像时，新的Dockerfile中使用FROM image-A指定基础镜像时，会自动执行ONBUILD指令内容，等价于在后面添加了两条指令 12345FROM image-A#Automatically run the followingADD . /app/srcRUN /usr/local/bin/python-build --dir /app/src 8.3 创建镜像 编写Dockerfile完成后，通过docker build命令来创建镜像 格式：docker build [options] path 读取指定路径下的Dockerfile，并将改路径下所有内容发送给Docker服务端，由服务端来创建镜像。因此，一般建议放置Dockerfile的目录为空目录 .dockerignore文件可以让Docker忽略路径下的目录和文件 例如： sudo docker build -t build_repo/first_image /tmp/docker_builder/ -t:指定镜像的标签 Reference: 论docker中 CMD 与 ENTRYPOINT 的区别Dockerfile用于自动化构建一个docker镜像。Dockerfile里有 CMD 与 ENTRYPOINT 两个功能咋看起来很相似的指令，开始的时候觉得两个互用没什么所谓，但其实并非如此： CMD指令：The main purpose of a CMD is to provide defaults for an executing container.CMD在容器运行的时候提供一些命令及参数，用法如下： CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form) CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT) CMD command param1 param2 (shell form) 第一种用法：运行一个可执行的文件并提供参数。第二种用法：为ENTRYPOINT指定参数。第三种用法(shell form)：是以”/bin/sh -c”的方法执行的命令。 如你指定:CMD [“/bin/echo”, “this is a echo test ”]build后运行(假设镜像名为ec):docker run ec就会输出: this is a echo test是不是感觉很像开机启动项，你可以暂时这样理解。 CMD注意点docker run命令如果指定了参数会把CMD里的参数覆盖：（这里说明一下，如：docker run -it ubuntu /bin/bash命令的参数是指/bin/bash 而非-it ,-it只是docker的参数，而不是容器的参数，以下所说参数均如此。） 同样是上面的ec镜像启动：docker run ec /bin/bash就不会输出：this is a echo test，因为CMD命令被/bin/bash覆盖了。 ENTRYPOINT字面意思是进入点，而它的功能也恰如其意。An ENTRYPOINT allows you to configure a container that will run as an executable.它可以让你的容器功能表现得像一个可执行程序一样。容器功能表现得像一个可执行程序一样，这是什么意思呢？ 直接给个例子好说话：例子一：使用下面的ENTRYPOINT构造镜像：ENTRYPOINT [&quot;/bin/echo&quot;]那么docker build出来的镜像以后的容器功能就像一个/bin/echo程序：比如我build出来的镜像名称叫imageecho，那么我可以这样用它：docker run -it imageecho “this is a test”这里就会输出”this is a test”这串字符，而这个imageecho镜像对应的容器表现出来的功能就像一个echo程序一样。 你添加的参数“this is a test”会添加到ENTRYPOINT后面，就成了这样/bin/echo “this is a test” 。现在你应该明白进入点的意思了吧。 例子二：ENTRYPOINT [&quot;/bin/cat&quot;]构造出来的镜像你可以这样运行(假设名为st)：docker run -it st /etc/fstab这样相当： /bin/cat /etc/fstab 这个命令的作用。运行之后就输出/etc/fstab里的内容。ENTRYPOINT有两种写法：写法一：ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (the preferred exec form)写法二：ENTRYPOINT command param1 param2 (shell form)你也可以在docker run 命令时使用–entrypoint指定（但是只能用写法一）。下面是我把ENTRYPOINT设为[“/bin/sh -c”]时候运行的情况： 123456linux-oj9e:/home/lfly/project/docker # `docker run -it t2 /bin/bash`root@4c8549e7ce3e:/# psPID TTY TIME CMD1 ? 00:00:00 sh9 ? 00:00:00 bash19 ? 00:00:00 ps 可以看到PID为1的进程运行的是sh，而bash只是sh的一个子进程，/bin/bash只是作为 /bin/sh -c后面的参数。 CMD可以为ENTRYPOINT提供参数，ENTRYPOINT本身也可以包含参数，但是你可以把那些可能需要变动的参数写到CMD里而把那些不需要变动的参数写到ENTRYPOINT里面例如: 123FROM ubuntu:14.10 ENTRYPOINT [\"top\", \"-b\"] CMD [\"-c\"] 把可能需要变动的参数写到CMD里面。然后你可以在docker run里指定参数，这样CMD里的参数(这里是-c)就会被覆盖掉而ENTRYPOINT里的不被覆盖。 ENTRYPOINT注意点注意点１： ENTRYPOINT有两种写法，第二种(shell form)会屏蔽掉docker run时后面加的命令和CMD里的参数。 注意点２： 网上有资料说ENTRYPOINT的默认值是[”/bin/sh -c”]，但是笔者在试验的时候得到的结果并不是这样的。笔者使用ENTRYPOINT [“/bin/sh -c”] 指令构造一个以/bin/sh -c为进入点的镜像，命名为sh，然后我可以这样运行：docker run -it sh “while(ture ) do echo loop; done”运行结果就是无限输出loop。但如果直接运行一个ubuntu:14.10镜像，情况不是这样的：docker run -it ubuntu:14.10 “while(ture ) do echo loop; done” 得到这样的错误：linux-oj9e:/home/lfly # docker run -it ubuntu:14.10 “while(true) do echo this; done” 2014/11/16 18:07:53 Error response from daemon: Cannot start container 4bfe9c6faeec3ed465788a201a2f386cb1af35aba197dbc78b87c0d5dda1f88e: exec: “while(true) do echo this; done”: executable file not found in $PATH 可以猜想默认情况下ENTRYPOINT并不是[“/bin/sh -c”]。而且直接运行ubuntu:14.10列出程序也可以看到PID为1的程序并不是sh。所以更否定了网友的说法，ENTRYPOINT并不默认为[“/bin/sh -c”] 。","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第七章 网络基础配置","date":"2017-12-26T07:29:01.000Z","path":"2017/12/26/Docker技术入门与实战-第七章-网络基础配置/","text":"Docker的网络功能包括： 使用端口映射机制将容器内应用服务提供给外部网络 通过容器互联系统让多个容器之间进行快捷的网络通信 7.1 端口映射实现访问容器 映射Host主机上的特定端口到容器中的特定端口 sudo docker -it -p 8081:80 --name mynginx nginx /bin/bash -p:映射指定端口 sudo docker -it -P --name mynginx nginx /bin/bash -P:随机映射一个49000~49900的端口至容器内部开放的网络端口 查看端口映射情况 sudo docker ps -a sudo docker ps -l sudo docker port mynginx 查看容器的日志 sudo docker logs mynginx:所有历史日志 sudo docker logs -f mynginx:容器的实时日志 映射Host主机上的特定ip的特定端口到容器中的特定端口 sudo docker -it -p 127.0.0.1:8081:80 --name mynginx nginx /bin/bash 映射Host主机上的特定ip的特定任意端口到容器中的特定端口 sudo docker -it -p 127.0.0.1::80 --name mynginx nginx /bin/bash 绑定随机的一个host端口到容器中的80端口 7.2 容器互联 容器的连接可以使接收容器看到源容器的地址等信息 执行docker run的时候如果添加--rm标记，则容器在终止后会立刻删除；故：--rm和-d参数不能同时使用 使用--link参数可以让容器之间安全的互联 步骤： 创建一个数据库容器 sudo docker run -d --name db postgres 创建一个web容器，然后将其连接到db容器上 sudo docker run -d -P --name web --link db:linkName nginx --link name:alias，其中name是要连接的容器的名称，alias是这个连接的别名 docker在两个互联的容器之间创建了一个安全隧道，而且不用映射他们的端口到Host主机上，从而避免了暴露数据库端口到外部网络上 查看容器的连接信息 在容器内利用env命令查看器环境变量 在容器内查看其/etc/hosts文件内容","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第六章 数据管理","date":"2017-12-26T06:06:06.000Z","path":"2017/12/26/Docker技术入门与实战-第六章-数据管理/","text":"6.1 数据卷 6.2 数据卷容器 6.3 利用数据卷容器迁移数据 容器中管理数据的方式有两种： 数据卷 数据卷容器 6.1 数据卷 数据卷特性： 数据卷可以在容器之间共享和重用 对数据卷的修改会立马生效 对数据卷的更新，不会影响镜像 卷会一直存在，直到没有容器使用它 数据卷的使用，类似于Linux下对目录或文件进行mount操作 在容器内创建一个数据卷 使用-v标记可以在容器内创建一个数据卷 sudo docker run -d -P --name web -v /webapp nginx /bin/bash -P：开放容器需要暴露的端口给主机 -v：创建了一个/webapp的数据卷，并挂载到了名为web的容器中 挂载一个主机目录作为数据卷 使用-v标记可以将一个本地已有的目录到容器中作为数据卷 sudo docker run -d -P --name web -v /src/webapp:/opt/webapp nginx /bin/bash 将本地的/src/webapp目录挂载到了web容器中的/opt/webapp目录下 本地目录必须是绝对路径，如果目录不存在，Docker会自动创建它 自定义数据卷读写权限： sudo docker run -d -P --name web -v /src/webapp:/opt/webapp:ro nginx /bin/bash 默认是rw权限，ro为只读 挂载一个本地主机文件作为数据卷 使用-v标记可以将单个文件挂载到容器中作为数据卷 sudo docker run -d -P --name web -v ~/.bash_history:/home/.bash_history nginx /bin/bash 6.2 数据卷容器 若要在容器间共享一些持续更新的数据，数据卷容器是最简单的方式 数据卷容器就是带有数据卷的普通容器 挂载过程 创建一个带有数据卷的普通容器 sudo docker run -it -v /dbdata --name dbdata ubuntu 在其他容器中使用--volumes-from containerName来挂载数据卷容器中的数据卷 sudo docker run -it --volumes-from dbdata --name db1 ubuntu sudo docker run -it --volumes-from dbdata --name db2 ubuntu 此时，db1、db2容器都挂载了同一个数据卷到各自的/dbdata目录下 多次使用--volumes-from containerName可以挂载多个数据卷容器 也可以从其他已经挂载了容器卷的容器来挂载数据卷 sudo docker run -it --volumes-from db1 --name db3 ubuntu 删除挂载的容器 如果删除了挂载的容器(包括dbata、db1、db2),数据卷都不会被自动删除 如果要删除一个数据卷，必须要在删除最后一个还挂载着它的容器时，显式的使用docker rm -v来删除其挂载的数据卷 6.3 利用数据卷容器迁移数据 备份 将挂载的/dbdata的数据卷压缩，然后备份到/backup，且容器中的/backup目录与主机的/backup目录相关联 sudo docker run --volumes-from dbdata -v ${pwd}:/backup --name worker ubuntu tar cvf /backup/backup.tar /dbdata 恢复 恢复数据到另一个容器:将，且另一个容器中的/backup目录与主机中用于备份的/backup目录相关联，然后解压其备份的数据到新容器中的数据卷中 sudo docker run--volumes-from dbdata2 -v ${pwd}:/backup busybox tar xvf /backup/backup.tar","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第五章 仓库","date":"2017-12-23T09:54:36.000Z","path":"2017/12/23/Docker技术入门与实战-第五章-仓库/","text":"注意：注册服务器(Registery)是存放仓库的具体服务器 例如：仓库地址”dl.dockerpool.com/ubuntu”，其中“dl.dockerpool.com”就是Registery地址，“ubuntu”是仓库名 5.1 DockerHub 仓库中单个词（没有前缀）的镜像名是官方镜像；另一种镜像名类似于”tim/ubuntu”的镜像是用户上传的镜像 自动创建 自动创建可以使得用户能够通过Docker Hub指定跟踪一个目标网站（github）上某个项目某个分支，一旦发现该分支更新了，它能通过里面的Dockerfile自动创建新的镜像 5.2 DockerPool DockerPool是国内较大的Docker社区，它提供了Docker镜像库服务 5.3 创建和使用私有仓库 安装本地Registery 在安装好Docker以后，可以通过下载官方的Registery镜像，然后在本地容器中运行该镜像 docker run -d -p 5000:5000 registry -v /opt/data/registery:/temp/registery: -p：端口映射 -v：目录映射 管理私有仓库 2.1 向私有仓库push镜像 docker push 192.168.2.37/test 2.2 从私有仓库pull镜像 docker pull 192.168.2.37/test 拉下来的镜像可以通过docker tag重新将其打标签","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第四章 容器","date":"2017-12-23T07:40:34.000Z","path":"2017/12/23/Docker技术入门与实战-第四章-容器/","text":"4.1 创建容器 创建容器：docker create eg：docker create -it ubuntu:latest -t：让docker分配一个伪终端并绑定到标准输出上 -i：让容器在标准输入保持打开 查看所有容器进程 docker ps -a 创建并启动容器 启动容器：docker start ubuntu 创建并启动容器: docker run ubuntu 等价于(create+start)： docker create -it ubuntu:latest docker start ubuntu 退出容器 Ctrl+d, 或者exit退出容器 一旦退出容器后，容器就自动处于终止状态；这是因为一旦容器中的任务运行完毕后，容器就没有继续运行的必要了 守护态运行： 加参数”-d”,进入守护态运行，启动后会返回一个唯一的ID docker run -d ubuntu /bin/bash -c “while true; do echo heello world; sleep 1; done 查看容器内部的日志：`docker logs CONTAINER 4.2 终止容器 docker stop [-t | --time[ = 10]] 它会首先向容器发生SIGTERM信号，等待一段时间后（默认10秒），再发送SIGKILL信号终止容器 dokcer kill：直接发送SIGKILL信号来终止容器 docker restart: 终止容器后再启动 4.3 进入容器 attach命令 docker attach DOCKERNAME|ID 缺点：多个窗口同时attach到同一个容器时，所有窗口都会同步显示。当某个窗口阻塞时，其他窗口都无法执行操作。 exec命令：允许在容器内直接运行命令 docker exec -it dockerNAME|ID /bin/bash nsenter工具： 使用nsenter工具要先找到对应docker的pid docker inspect --format &quot;{\\{.State.Pid}\\}&quot; containerID (去掉两个\\，hexo的bug!!) nsenter --target pid --mount --uts --ipc -- net --pid 4.4 删除容器 docker rm containerID：删除一个处于终止状态的容器 -f：可以强行删除一个运行中的容器 -l：删除容器的连接，但保留容器 -v：删除容器挂载的数据卷 4.5 导入和导出容器 导出容器 docker export CONTAINER无论容器是否正在运行，都可以导出 docker export CONATINERID &gt; test_container.tar 导入容器： docker import可以把一个容器快照导入本地镜像库； 容器快照文件将会丢失所有的历史记录和元数据，而只保留最后的快照状态，因此在导入时可以从新指定标签等元数据信息 docker load可以把一个镜像文件导入到本地镜像库； 镜像文件将会保存完整的记录，体积也要大一些","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第三章 镜像","date":"2017-12-23T06:49:27.000Z","path":"2017/12/23/Docker技术入门与实战-第三章-镜像/","text":"3.1 获取镜像 指定标签：sudo docker pull ubuntu：14.04 指定仓库：sudo docker pull dl.dockerpool.com:5000/ubuntu 3.2 查看镜像信息 列出已有镜像：sduo docker images 为本地镜像打标签：sudo docker tag originRepoName:originTag newRepoName:newTag 获取镜像的详细信息:sudo docker inspect dockerId 3.3 搜索镜像：sudo docker search oracle --automated=false：仅显示自动创建的镜像 --no-trunc=false：输出信息不截断显示 -s, --stars=0：指定显示评价为指定星级以上的镜像 3.4 删除镜像：sudo docker rmi [IMAGE...] IMAGE：为镜像标签或者ID 强行删除镜像：sudo docker rmi -f [IMAGE...] 如果有镜像创建的容器存在时，镜像文件是不能被删除的，只能用强制删除，但这样会造成一些问题 正确做法是：先删除其创建的容器，再删除镜像 3.5 创建镜像： 5.1 基于镜像的容器创建 sudo docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] OPTIONS: -a，--author=&quot;&quot;：作者 -m, --message=&quot;&quot;：提交消息 -P, --pause=true：提交时暂停容器运行 eg：sudo docker commit -m &quot;Added a new file&quot; -a &quot;Docker Newer&quot; a925cb40b3f0 test:1.0.1 5.2 基于本地模板导入：从一个本地的模板文件中导入一个镜像 sudo cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04 5.3 基于Dockerfile创建 3.6 存出和载入镜像 6.1 存出：docker save -o ubuntu_14.04.tar ubuntu:14.04 6.2 载入：可以从存出的本地文件中再导入到本地镜像库 docker load --input ubuntu_14.04.tar docker load &lt; ubuntu_14.04.tar 3.7 上传镜像 sudo docker push NAME[:TAG] ch3.7-1 默认上传到Docker Hub","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第二章 Docker的核心概念和安装","date":"2017-12-20T12:54:36.000Z","path":"2017/12/20/Docker技术入门与实战-第二章-Docker的核心概念和安装/","text":"2.1 核心概念 Docker镜像：类似于虚拟机镜像，可以将它理解为一个面向Docker引擎的只读模板，包含了文件系统 Docker容器：容器中可以运行Docker镜像，可以将其理解为简易版的Linux系统环境 镜像本身是只读的，镜像在容器中启动后，Docker会在镜像的最上层创建一个可写层，镜像本身保持不变 Docker仓库：是Docker集中存放镜像文件的场所 注册服务器（Registry）是存放仓库的地方，一个注册服务器包含多个仓库 每个仓库都集中存放着某一类镜像，每个镜像通过标签(tag)来区分（例如：Ubuntu仓库里，通过14.04，12.04这些标签来区分） 2.2 安装Docker Docker支持在Ubuntu、CentOS、Windows以及MacOS系统上使用 Ubuntu： 14.04以上的版本已经在官方软件源中自带了Docker包 14.04以下的版本需要先更新内核 CentOS：支持CentOS6及以后的版本 CentOS 6：可以从EPEL库安装Docker CentOS 7：CentOS-Extras源已经内置Docker，可以直接安装 Windows：由于Docker使用了Linux内核特性，因此Windows上运行需要额外的一个虚拟机来提供Linux支持。推荐使用Boot2Docker工具，它将依次安装VirtualBox、MSYS-git、boot2docker Linux ISO镜像 MacOS: 同样需要使用Boot2Docker工具","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Docker技术入门与实战-第一章 初识Docker","date":"2017-12-20T12:05:11.000Z","path":"2017/12/20/Docker技术入门与实战-第一章-初识Docker/","text":"1.1 什么是Docker 虚拟化实现方式： 硬件模拟 利用操作系统本身已有的机制和特性（Docker实现方式） Docker主要目标 “Build, Ship and Run Any App, Anywhere”(一次封装，到处运行) 对应用组件的封装(Packaging)、分发(Distribution)、部署(Deployment)、运行(Runtime)等生命周期进行管理 Linux容器技术 Docker引擎的基础是Linux容器(Linux Containers, LXC)技术 LXC已被集成到主流Linux内核 与虚拟化相比，容器既不需要指令级模拟，也不需要即使编译。容器可以在核心CPU上本地运行，而不需要任何专门的解释机制 从Linux容器到Docker 在LXC的基础之上，Docker进一步的优化了容器的使用体验，提供了各种容器的管理工具，而无需用户关注底层的操作 1.2 为什么要使用Docker Docker容器虚拟化的好处 通过容器打包应用，意味着迁移只需要在新的服务器上启动需要的容器就可以了，大大节省了部署的风险和时间 Docker在开发和运维中的优势 更快速的交付和部署 更高效的资源利用。Docker不需要二位的虚拟化管理程序（Virtual Machine Manager，VMM 以及Hyperbisor）支持，它是内核级别的虚拟化 更轻松的迁移和扩展。Docker容器机会可以在任何平台上运行 更简单的更新管理。使用Dockerfile，只需要小小的配置修改，就可以代替以往大量的更新工作 Docker与虚拟机的比较 Docker容器很快：启动和停止可以秒级实现 Docker容器对系统资源需求很少，一个主机可以同时运行上千个Docker容器 Docker通过类似Git的操作来方便用户获取、分支和更新应用镜像 Docker通过Dockerfile配置文件来支持灵活的自动化创建和部署机制，提高工作效率 1.3 虚拟化与Docker 虚拟化的核心就是对资源进行抽象 软件虚拟化 应用虚拟化：类似于软件模拟器和wine这样的软件 平台虚拟化： 完全虚拟化：虚拟机模拟完整的底层硬件环境和指令特权的执行过程，客户操作系统无需进行修改；例如：VMware Workstation、Virtual Box等 硬件辅助虚拟化：利用硬件(主要是CPU)来处理特殊的指令来实现完全虚拟化的功能。例如：Intel-VT和AMD-V 部分虚拟化：只针对部分的硬件资源进行虚拟化 超虚拟化：部分硬件接口以软件的形式提供给客户机操作系统 操作系统级虚拟化：内核通过创建多个虚拟的操作系统实例（内核和库）来隔离不同的进程，容器就是这样。","categories":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://matlabchina.cn/tags/Docker/"}]},{"title":"Thinking in Java 第十四章 类型信息","date":"2017-12-19T07:47:45.000Z","path":"2017/12/19/Thinking-in-Java-第十四章-类型信息/","text":"运行时类型信息使得你可以在程序运行时发现和使用类型信息 RTTI的两种方式： “传统的”RTTI，假定我们在编译时已经知道了所有的类型 “反射”机制，在运行时发现和使用类的信息 14.1 为什么需要RTTI 使用RTTI，可以查询某个引用所指向的对象的确切类型，针对确切类型来执行某些特殊的操作，而在更上层的接口类型中无法获取这些信息 14.2 Class对象 Class对象就是用来描述每个类的信息的类，每个类都有一个Class对象，他被保存在同名的.class文件中 所有的类都是在对其第一次使用时，动态加载到JVM中的 无论何时，只要想在运行时获得类型信息，就必须首先获得恰当的Class对象的引用。 获取目标类的Class对象 Class.forName(“TargetClassName”);不需要为了获得Class引用而持有该类型的对象 obj.getClass():通过一个对象，获得它所属类的Class引用 Reference:JAVA中类、实例与Class对象 类字面常量 4.1 形式如FancyToy.class 类字面常量不仅可应用于普通类，也可以应用于接口、数组、基本数据类型、基本数据类型的包装器类 基本数据类型用.class获得Class引用，包装类用.TYPE获得Class引用 4.2 由.class来创建对Class对象的引用时，并不会自动的初始化该Class对象 为类而做的准备包含三个步骤： 加载：由类加载器执行的。通过查找字节码（从classpath中开始查找），并从这些字节码中创建一个Class对象 链接：在链接阶段会先验证类中的字节码；然后为静态域分配存储空间 初始化：如果该类有父类，则对其父类先进行初始化，执行静态初始化器和静态初始化块。 类加载器首先检查这个类的Class对象是否已经加载。如果尚未加载，默认的类加载器就会根据类名查找.class文件，在加载过程中，也会验证类的字节码 4.3 仅使用.class语法来获得对Class对象的引用并不会引发目标类的初始化。但是为了产生Class引用，Class.forName()会立即进行初始化，就像在对initable3引用的创建中看到的。 static final值是一个编译器常量，因此Initable.staticFinal并不会出发对Initable类的初始化；但如果仅仅是static final还不足以确保这种行为，因为这种常量也可能是通过其他语句生成的，它就不是一个“编译器常量”了，例如：对Initable.staticFinal2的访问就会触发类的初始化 如果一个域是static不是final的，那么对它的访问时，就会在它被读取之前，先进行链接（为static域分配存储空间）和初始化，就像对Initable2.staticNonFinal访问时一样 4.4 泛化的Class引用 使用泛型语法，可以使Class引用只能指向其声明的类型 123Class&lt;Integer&gt; genericIntClass=int.class;//won't compile//Class&lt;Number&gt; genericIntClass=int.class; 为了在使用泛化的Class引用时放松限制，使用通配符 1234Class&lt;Integer&gt; genericIntClass=int.class;//won't compileClass&lt;? extends Number&gt; genericIntClass=int.class;Class&lt;? super FancyToy&gt; genericIntClass=Toy.class; 向Class引用添加泛型语法的原因仅仅是为了提供编译器类型检查 一个有趣的事：将泛型语法应用于Class对象时，newInstance()返回该对象的确切类型；而不应用泛型语法于Class对象时，它将返回基本的Object类型 4.5 新的转型语法 cast()方法接收一个对象，然后将其转型为Class引用的类型 Class.asSubclaass():将一个类对象转型为更加具体的类型 14.3 类型转换前先做检查 已知的RTTI的形式包括： 传统的类型转换：如：(Shape)circle; Java要执行类型检查，被称为“类型安全的向下转型”：编译器将检查向下转型是否合理，因此它不允许向下转型到实际上不是待转型的子类的类型上 使用instanceof进行类型检查 使用Class.forName()与使用TestClass.class(类字面常量)来获得Class引用的区别是： 使用Class.forName()需要try-catch语块来捕获IllegalAccessException等异常，因为编译器无法对其做静态检查；而使用TestClass.class(类字面常量)无需try-catch语块，因为编译器可以对其做静态检查 如果程序中编写过多的instanceof表达式，就说明你的设计可能存在瑕疵 动态的instanceof 使用一个预填充所有Class对象的Map,在Instacne()方法中，就不再需要instanceof表达式了 Class.isAssignableFrom(Class superClass):执行运行时检查，检查该Class对象是否是superClass的子类 14.4 注册工厂 实现：将每个实现类中包含一个static的工厂类，然后再基类中保存一个工厂基类的对象列表，通过这个工厂列表就可以实现动态的生成各个子类的对象 目的：将具体的实现子类，通过内嵌的工厂类在进行实例化生成；在基类中只需要保存一个子类的内嵌工厂对象列表即可。这样就实现了具体类对象的生成和这些类的“消费”的分离 1234567891011121314151617181920212223242526272829@startumlinterface Factory&lt;T&gt;&#123; + T create()&#125;class Part&#123; - List&lt;Factory&lt;? extends Part&gt;&gt; partFactories - static init partFactories&#123;add partFactories&#125; + String toString() + Part createRandom()&#125;class FuelFilter&#123; - class Factory implements Chapter14_RTTI.Factory&lt;FuelFilter&gt;&#123; create()&#125;&#125;class CabinAirFilter&#123; - class Factory implements Chapter14_RTTI.Factory&lt;CabinAirFilter&gt;&#123; create()&#125;&#125;class FanBelt&#123; - class Factory implements Chapter14_RTTI.Factory&lt;FanBelt&gt;&#123; create()&#125;&#125;Part &lt;|-- FilterFilter &lt;|-- FuelFilterFilter &lt;|-- CabinAirFilterPart &lt;|-- BeltBelt &lt;|-- FanBelt@enduml 12345package Chapter14_RTTI; public interface Factory&lt;T&gt; &#123; T create();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package Chapter14_RTTI; import java.util.ArrayList;import java.util.List;import java.util.Random; public class Part &#123; @Override public String toString()&#123; return this.getClass().getSimpleName(); &#125; static List&lt;Factory&lt;? extends Part&gt;&gt; partFactories=new ArrayList&lt;Factory&lt;? extends Part&gt;&gt;(); static &#123; partFactories.add(new FuelFilter.Factory()); /**继续添加类型，，，省去，*/ &#125; private static Random random=new Random(47); public static Part creatRandom()&#123; return partFactories.get(random.nextInt(partFactories.size())).create(); &#125;&#125;class Filter extends Part&#123; &#125;class FuelFilter extends Filter&#123; public static class Factory implements Chapter14_RTTI.Factory&lt;FuelFilter&gt;&#123; @Override public FuelFilter create()&#123; return new FuelFilter(); &#125; &#125;&#125;class FuelFilterS extends FuelFilter&#123; public static class Factory implements Chapter14_RTTI.Factory&lt;FuelFilterS&gt;&#123; @Override public FuelFilterS create()&#123; return new FuelFilterS(); &#125; &#125;&#125;class AirFilter extends Filter&#123; public static class Factory implements Chapter14_RTTI.Factory&lt;AirFilter&gt;&#123; @Override public AirFilter create()&#123; return new AirFilter(); &#125; &#125;&#125;class OilFilter extends Filter&#123; public static class Factory implements Chapter14_RTTI.Factory&lt;OilFilter&gt;&#123; @Override public OilFilter create()&#123; return new OilFilter(); &#125; &#125;&#125;class Belt extends Part&#123; &#125;class FanBelt extends Belt&#123; public static class Factory implements Chapter14_RTTI.Factory&lt;FanBelt&gt;&#123; @Override public FanBelt create()&#123; return new FanBelt(); &#125; &#125;&#125;class GeneratorBelt extends Belt&#123; public static class Factory implements Chapter14_RTTI.Factory&lt;GeneratorBelt&gt;&#123; @Override public GeneratorBelt create()&#123; return new GeneratorBelt(); &#125; &#125;&#125;class PowerSteeringBelt extends Belt&#123; public static class Factory implements Chapter14_RTTI.Factory&lt;PowerSteeringBelt&gt;&#123; @Override public PowerSteeringBelt create()&#123; return new PowerSteeringBelt(); &#125; &#125;&#125; 12345678package Chapter14_RTTI; public class Test &#123; public static void main(String[] args)&#123; for(int i=0;i&lt;10;i++) System.out.println(Part.creatRandom()); &#125;&#125; 1234567891011//输出FuelFilterFuelFilterFuelFilterFuelFilterFuelFilterFuelFilterFuelFilterFuelFilterFuelFilterFuelFilter 14.5 instanceof与Class的等价性 以instanceof的形式或isInstance()的形式来执行类型检查的结果相同 通过x.getClass()获取的Class引用，然后来通过==或equals()来检查Class对象是否相等，其检查结果也一样。 但是，两组测试的结论却不同。instanceof保持了类型的概念，它指的是“你是这个类吗？或者你是这个类的派生类？” 如果用==比较实际的Class对象，就没有考虑继承 14.6 反射：运行时的类信息 要通过RTTI来获得某个对象的确切信息,则该类型就必须在编译阶段就已知； RTTI和反射的区别是： 对RTTI来说，编译器在编译时打开和检查.class文件（换句话说，我们可以以“普通”方式调用对象的所有方法） 对于反射机制来说，.class文件在编译时是不可获得的，所以在运行时打开和检查.class文件 Class类和java.lang.reflect类库一起对反射的概念进行了支持，该类库包含了以下类： Field Method Constructor 这些类型的对象是由JVM在运行时创建的，用以表示未知类里对应的成员 Class.forName()生成的结果在编译时是不可知的，因为所有的方法特征签名信息都是在执行时被取出来的 反射机制提供了足够的支持，使得能够创建一个在编译时完全未知的对象，并调用此对象的方法 14.7 动态代理 普通的代理模式就是通过组合的方式，由另一个类中的方法来代理被组合对象的的方法，在被代理的过程中，可对被组合对象的方法进行一些行为的修改 1234567891011121314151617181920@startumlinterface Interface&#123; + void doSomething() + void doSomethingElse(String arg)&#125;Class RealObject&#123; + void doSomething() + void doSomethingElse(String arg)&#125;Class Proxy&#123; - Interface interface + void doSomething() + void doSomethingElse(String arg)&#125;Class SimpleProxyDemo&#123; + void consumer(Interface iface)&#125;Interface &lt;-- RealObjectInterface &lt;-- Proxy@enduml Java的动态代理：动态的创建代理并动态的处理对所代理方法的调用 静态方法Proxy.newProxyInstance()可以创建动态代理，它需要三个参数 一个类加载器：通常可以从已被加载的对象中获取其类加载器，然后传递给它 一个你希望该代理类实现的接口列表（不是类或抽象类） 一个实现了InvocationHandler接口的一个实现类，在这个实现类中override了invoke方法，invoke()方法中传递进来了代理对象 动态代理可以将所有调用重定向到调用处理器，因此通常会想调用处理器传递给一个“实际”对象的引用，从而使得调用处理器在其中执行中介任务时，可以将请求转发 14.8 空对象1.","categories":[{"name":"ThinkingInJava","slug":"ThinkingInJava","permalink":"http://matlabchina.cn/categories/ThinkingInJava/"}],"tags":[{"name":"ThinkingInJava","slug":"ThinkingInJava","permalink":"http://matlabchina.cn/tags/ThinkingInJava/"}]},{"title":"Thinking in Java 第十三章 字符串","date":"2017-12-18T09:40:50.000Z","path":"2017/12/18/Thinking-in-Java-第十三章-字符串/","text":"13.1 不可变String 把String对象作为方法传参时，都会拷贝一份引用；一旦对该引用进行修改，那么该引用将会指向一个新的对象,并返回 upcase(String s)等方法并不会修改s所指的对象，而是返回一个新的String对象的引用 13.2 重载”+”与StringBuilder 用于’String’的“+”和“+=”是java中仅有的两种重载过的运算符 在while循环中使用如下代码： 123while(flag)&#123; String s=\"hello\"+\" \"+\"world\"+\" ?\";&#125; jvm会自动给每次迭代产生一个StringBuilder用于生成字符串 javap -c ClassName:反编译代码，-c：表示将生成JVM字节码 StringBuilder是线程不安全的；StringBuffer是线程不安全的 13.3 无意识的递归 编译器看到String对象后面接着一个“+”，编译器会将后面的对象试图转换为String，因此就会再一次调用toString()对象 如果套打印出对象的内存地址，应该调用super.toString() 13.4 String上的操作 String类的方法都只会返回一个新的String对象。如果没有发生改变，String的方法只是返回指向原对象的引用。 13.5 格式化输出 System.out.format()等价于System.out.printf() 可用于PrintStream和PrintWriter对象中，其中包括System.out对象 12System.out.printf(\"Row 1 [%d %d]\",x,y);System.out.format(\"Row 1 [%d %d]\",x,y); Formatter类 2.1 java中，新的格式化功能店铺由java.util.Formatter类处理 12Formatter f=new Formatter(System.out);f.format(\"Row 1 [%d %d]\",x,y); 2.2 Formatter的构造函数重载接受输出到多个输出目的地，包括PrintStream、OutputStream、File 2.3 格式化说明符： 格式: 1% [argument_index$][flags][width][presion]conversion width:代表显示占位宽度 presion：代表浮点数小数位数；String对象输出字符最大数量；对整数使用presion将会触发异常 boolean和Boolean类型的值在转换时，只要不是Null，就一律转换为true，其中包括0; 2.4 String.format() 在String.format()内部，它也是创建一个Formatter对象，然后将你传入的参数传给Formatter 13.6 正则表达式 基础 在java中, \\\\表示后面是一个正则表达式的反斜线；\\\\\\\\表示插入一个普通的反斜线 换行，制表符之类的东西只需要使用单反斜线\\n\\t 量词 贪婪型：默认的都是贪婪型的。贪婪表达式会为所有可能的模式发现尽可能多的匹配。 勉强型：用?来指定，这个量词匹配满足模式所需的最少字符 占有型：当正则表达式被应用于字符串时，它会产生相当多的状态，以便在匹配失败时可以回溯。而“占用的”量词并不保存这些中间状态，因此可以防止回溯。它们常常被用于防止正则表达式失控 Pattern和Matcher 12Pattern p=new Pattern(regx);Matcher m=p.matcher(string); Pattern常用方法： boolean mathces()：判断整个输入字符串是否匹配正则表达式模式 boolean lookingAt()：判断该字符串（不必是整个字符串）的始部分能够匹配模式 boolean find()：在CharSequence中查找多个匹配 boolean find(int start)：从第i个字符开始匹配 Matcher常用方法： int groupCount():返回Matcher的模式中分组的数目，不包括0组 String group():返回前一次匹配的第0组 String group(int i):返回前一次匹配的第i组 int start(int group):返回前一次匹配的第i组的起始位置 int end(int group):返回前一次匹配的第i组的结束位置+1 Pattern标记 Pattern.compile(String regx,int flag)方法接受一个标记参数 此外，也可以将标记参数直接写在正则表达式里： 1Pattern.compile(\"(?m)(\\\\S+)\\\\s+\"); split():将输入字符串断开成字符串数组 1Pattern.compile(\"!!\").spilt(inputString); 替换操作 12String.replaceFirst()String.replaceAll() 1234567Pattern p=new Pattern(regx);Matcher m=p.matcher(string);m.repalceFirst(string);m.repalceAll(string);m.appendReplacement(StringBuffer sbuf, String replacement);//执行迭代式的替换，替换结果写进sbufm.appendTail(StringBuffer sbuf);//执行一次或多次appendReplacement()后，调用此方法将输入字符串余下的部分复制到sbuf中 reset():Matcher对象调用reset方法后，可对新的字符串进行匹配 12345Matcher m=Pattern.compile(\"[frb][aiu][gx]\").matcher(\"fix the rug with bags\");while(m.find())&#123; //...&#125;m.reset(\"fix the rig with bags\"); 13.7 扫描输入 Scanner类 Scanner对象可以接受任何类型的输入对象，包括File、InputStream、String、具有read()方法的Readable对象。 Scanner的常用方法 next()方法可对输入对象进行匹配，分隔；默认返回匹配的下一个String nextInt()：返回匹配的下一个整数 hasnext():判断下一个输入分词是否所需的类型 定界符 默认Scanner对象根据空白字符进行分词，但是Scanner对象也可以指定自己所需的定界符 用正则表达式扫描 利用hasnext()方法进行迭代扫描 13.8 StringTokenizer Java引入正则表达式和Scanner类以前，分隔字符串的唯一方法是使用StringTokenizer来分词，但是功能很弱，现在已经不再使用 13.9 总结 随着几个java版本的升级，Java对字符串的支持已经相当完善了。但是仍然要注意使用的细节，如StringBuilder等","categories":[{"name":"ThinkingInJava","slug":"ThinkingInJava","permalink":"http://matlabchina.cn/categories/ThinkingInJava/"}],"tags":[{"name":"ThinkingInJava","slug":"ThinkingInJava","permalink":"http://matlabchina.cn/tags/ThinkingInJava/"}]},{"title":"Thinking in Java 第十二章 通过异常处理错误","date":"2017-12-15T05:52:56.000Z","path":"2017/12/15/Thinking-in-Java-第十二章-通过异常处理错误/","text":"12.1 概念 如果使用异常，就不必再方法调用处进行检查，因为异常机制将保证能够捕获这个错误；而只需要在某个地方处理错误，即“异常处理程序”。 异常处理把“描述在正常执行过程中做什么事”和“出了问题怎么办”的代码相分离 12.2 基本异常 异常代码执行过程： 使用new在堆上创建一个异常对象 当前的执行路径被终止，并且从当前环境中弹出对异常对象的引用 异常处理机制接管程序 异常处理的目的：将程序从错误状态中恢复出来，恢复到一个稳定执行的点上。 异常参数：所有的标准异常类都带有两个构造器： 一个默认构造器 一个接受字符串作为参数，以便能把相关信息放入异常对象的构造器。1234567891011121314151617181920public class NoSuchMethodException extends ReflectiveOperationException &#123; private static final long serialVersionUID = 5034388446362600923L; /** * Constructs a &lt;code&gt;NoSuchMethodException&lt;/code&gt; without a detail message. */ public NoSuchMethodException() &#123; super(); &#125; /** * Constructs a &lt;code&gt;NoSuchMethodException&lt;/code&gt; with a detail message. * * @param s the detail message. */ public NoSuchMethodException(String s) &#123; super(s); &#125;&#125; 异常返回的“地点”与函数返回的“地点”有所不同： 函数返回点就是函数调用处 异常的返回点必须要到一个“异常处理点”，这个位置可能离异常被抛出的地方跨越了方法调用栈的许多层次异常抛出时穿过的这个层次，都会被终止执行 12.3 捕获异常 异常处理程序： 123456789try &#123; throw new TimeoutException(\"hello\"); &#125; catch (final TimeoutException ex) &#123; ex.printStackTrace(); &#125; catch (final NullPointerException ex) &#123; ex.printStackTrace(); &#125; catch (final Exception e) &#123; ex.printStackTrace(); &#125; 终止与恢复： 异常处理一般有两种处理模型 终止模型：错误非常关键，以至于程序无法返回正常状态。此时，一旦抛出异常，就立马终止该被try的代码块 恢复模型：在异常处理程序中修正错误，然后尝试从新调用该方法 把try放在while循环里，这样就不断的进如try块，进行修正恢复 推荐使用终止模型的原因：恢复性的处理程序需要了解异常抛出的地点，这势必要包含依赖于抛出位置的非通用性代码，这导致了代码编写和维护的难度，对于异常可能会从血多地方抛出的大型程序来说，更是如此。 12.4 创建自定义异常 创建异常: 123456public MyException extends Exception&#123; public MyException()&#123;&#125; public MyException(String msg)&#123; super(msg); &#125;&#125; System.error将错误发送到标准错误流，它不会随着System.out一起被重定向 对于异常类来说，getMessage方法类似于toString方法 12.5 异常说明 异常说明使用了附加的关键字throws，后面接一个所有潜在异常类型的列表 123void f() throws TooBig, TooSmall&#123; //...&#125; 告诉客户端程序员，该方法所有可能抛出的异常 在使用该方法时，编译器就会提示你： 要么处理该异常 要么在调用的函数的异常说明中表明此方法将产生异常 11.6 捕获所有异常 常用异常类方法 获取异常信息： getMessage():获取详细信息 getLocalizedMessage():获取本地语言表示的详细信息 toString():返回对Throwable的简单描述 输出到流： printStackTrace():输出到标准错误流 printStackTrace(PrintStream):输出到PrintStream流 printStackTrace(java.io.PrintWriter):输出到PrintWriter流 记录异常栈帧信息 Throwable fillInStackTrace():用于在Throwable对象内部记录栈帧的当前状态 从Object继承的方法： getClass:返回此类的另一个新对象 getName：查询这个Class对象包含的包名称 getSimpleName(): 栈轨迹 printStackTrace()所提供的所有信息可以通过getStackTrace()获得 重新抛出异常 重新抛出异常会把异常抛给上一级环境中的异常处理程序，同一个try块后续的catch子句将被忽略 重新抛出异常时： 如果只是把当前异常对象抛出的话，那么stackTrace会在当前trace上继续增长 如果调用fillInStackTrace(),这将会覆盖原来的trace，而返回一个新的Throwable对象，该对象的trace起点就是当前位置 异常链 在重新抛出异常时，如果希望把原始的异常信息保存下来。所有的Throwable子类在构造器中都可以接受一个cause对象作为参数。 在Throwable子类中，只有三种基本的异常类提供了带cause参数的构造器，它们是Error、Exception和RuntimeException 如果要把其他类型的异常链接起来，应该使用initCause()方法，而不是cause参数的构造器 12.7 Java标准异常 Throwable表示任何可以被作为异常抛出的类 Throwable对象分为两种类型： Error:编译错误或系统错误 Exception:可以被抛出的基本类型 异常的基本概念就是用名称代表发生的问题 特例：RuntimeException: NullPointerException等运行时异常都是RuntimeException的子类，编译器不会强制对这些可能的异常进行异常说明，他们被称为不受检查的异常 RuntimeException类型的异常如果没有捕获，将会直达main()方法，在程序退出前调用printStackTrace 12.8 使用finally进行处理 finally语句：无论try块中是否发生异常，finally语句中的代码都将会执行 可以实现类似事务的机制，一旦发生异常，在finally语句块中可以实现各个状态的回滚 当涉及到break、continue语句时,finally语句同样会被执行 return之前，finally一样会被执行 缺憾：异常丢失 使用finally语句后，异常可能会丢失 前一个异常还没处理就抛出下一个异常，会造成前一个异常丢失 finally中放入return也会丢失异常 12.9 异常的限制 当覆盖方法时，只能抛出基类方法的异常说明里列出的那些异常 这样做的目的是当基类代码应用到其派生类对象时，一样能工作 派生类构造器的异常说明必须包含基类构造器的异常说明，可以多于基类构造器的异常说明列表 基类的普通方法有异常说明，继承类中覆盖的方法可以不写异常说明，因为这样在子类向上转型时，不会破坏对象的可替换性 子类中的重载方法，可以抛出父类方法中异常类的子异常类，同样不会破坏可替换性 不能基于异常说明来重载方法 在覆盖和继承中，基类的方法必须出现在派生类中；而在异常说明中，基类方法的异常说明不一定会出现在子类方法中。 12.10 构造器 在设计异常时通常会有一个问题（三种选择）： 把异常放在本层处理 把异常在本层处理一部分，再向上抛出相同异常 不做任何处理，直接向上抛出异常 如果用法恰当，直接向上抛出的确能简化编程 构造阶段发生异常，最好的处理方式是嵌套的try-catch-finally: 如果InputFile对象构造失败，则不会进入内部的try-catch语句，不会调用dispose()方法；如果构造成功，则进入内部的try-catch语句，然后在内部的finally语句块中调用dispose() 在创建需要清理的对象之后，立即进入try-finally语句块 Section1: 在可去除对象之后紧跟try-finally的原则 Section2：为了构造和清理，具有不能失败的构造器的对象可以群组在一起 Section3：处理那些具有可能失败的构造器，且需要清理的对象。对于每一个构造，都必须包含在自己的try-finally语句块中 12.11 异常捕获 异常处理系统会按照代码的书写顺序找出“最近”的处理程序。找到匹配的处理程序后，它就认为异常将得到处理，就不再继续查找 查找的时候并不要求异常与异常处理程序所声明的异常完全匹配。派生类对象也可以匹配其基类的处理程序 12.12 其他可选方式 异常处理的一个重要原则是：“只有在你知道如何处理的情况下才捕获异常” 异常处理的重要目标是：将异常处理代码和异常发生的地点相分离 历史 受检查的异常：这种在编译时被强制检查的异常称为”受检查的异常”。即在方法的声明中声明的异常。 不受检查的异常：在方法的声明中没有声明，但在方法的运行过程中发生的各种异常被称为”不被检查的异常”。这种异常是错误，会被自动捕获。 缺点： 瞬时风格报告错误（C语言）：过多的执行条件测试，难以阅读 Java的“被检查的异常”：异常处理代码跟随着异常产生的代码，破坏了程序的正常思路 异常说明的含义： 我的代码会产生异常，这由你来处理 我的代码忽略了这些异常，这由你来处理 观点 “被检查的异常”在小规模的程序中显得十分有效和清晰，但是一旦项目不断膨胀，过多的异常检查是的代码无法被管理 异常检查的核心是： 不在于编译器是否会强制程序员去处理错误，而是要有一致的、使用异常来报告错误的模型 不在于什么时候检查，而是一定要有类型检查。也就是说，必须强制程序使用正确的类型，至于强制施加于编译时还是运行时，倒没关系。 比起在编译时指出所有的错误，自动构建过程和单元测试的效果更能发现这些错误 反射和泛型就是用来补偿静态类型检查带来的过多限制 被检查的异常和不受检查的异常有什么区别？ A.被检查的异常应该用try-catch块代码处理，或者在main方法中用throws关键字让JRE了解程序可能抛出哪些异常。不受检查的异常在程序中不要求被处理或用throws语句告知。 B.Exception是所有被检查异常的基类，然而，RuntimeException是所有不受检查异常的基类。 C．被检查的异常适用于那些不是因程序引起的错误情况，比如：读取文件时文件不存在引发的FileNotFoundException。然而，不被检查的异常通常都是由于糟糕的编程引起的，比如：在对象引用时没有确保对象非空而引起的NullPointerException。 不受检查异常的基类RuntimeException.实际上在java中“不受检查的异常”是默认一定在程序中的，也就是说你不去声明使用它，它也会一直在被使用着。常见的RuntimeException异常包括：NullPointerException：见的最多了，其实很简单，一般都是在null对象上调用方法了。 NumberFormatException：字符串转换为数字时，例如 int i= Integer.parseInt(“ab3”); ArrayIndexOutOfBoundsException: 数组越界，比如 int[] a=new int[3]; int b=a[3]; ClassCastException:类型转换错误，比如 Object obj=new Object(); String s=(String)obj; ArithmeticException：算术错误，典型的就是0作为除数的时候。 IllegalArgumentException：非法参数，在把字符串转换成数字的时候经常出现的一个异常，我们可以在自己的程序中好好利用这个异常。 Java中所有异常或者错误都继承Throwable，我们把它分为三类： Error:所有都继承自Error，表示致命的错误，比如内存不够，字节码不合法等。 Exception:这个属于应用程序级别的异常，这类异常必须捕捉。 RuntimeException:RuntimeException继承了Exception，而不是直接继Error,这个表示系统异常，比较严重。 把异常传递给控制台 不进行异常处理，直接在main()方法上声明Exception异常，就不必写try-catch语句了，不再进行异常检查了 123public static void main throws Exception()&#123; ...//some exceptions may throw&#125; 把“被检查的类型”转换为“不检查的类型” 将“被检查的类型”包装进RuntimeException，这样既不会再进行异常检查，同时也不会把异常吞掉 12345try&#123; //... do somethin&#125;catch(IDoNotKnowWhatToDoWithThisCheckedException e)&#123; throw new RuntimeException(e);&#125; 12.13 异常使用指南","categories":[{"name":"ThinkingInJava","slug":"ThinkingInJava","permalink":"http://matlabchina.cn/categories/ThinkingInJava/"}],"tags":[{"name":"ThinkingInJava","slug":"ThinkingInJava","permalink":"http://matlabchina.cn/tags/ThinkingInJava/"}]},{"title":"Thinking in Java 第十一章 持有对象","date":"2017-12-14T07:11:25.000Z","path":"2017/12/14/Thinking-in-Java-第十一章-持有对象/","text":"11.1 泛型和类型安全的容器 @SuppressWarnings注解：告诉它对被批注的代码元素内部的某些警告保持静默。 @suppressWarnings（&quot;unchecked&quot;）：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型 通过使用泛型(eg: ArrayList&lt;Apple&gt;)可以在编译器防止将错误类型的对象放置到容器中。如果不指明Apple，容器中所有的对象都将被向上转型为Object 11.2 基本概念 你应该创建一个具体的类的对象，将其转型为对应的接口，然后再其余的代码中都使用接口。 1List&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;(); 11.3 添加一组元素 Arrays.asList()方法接受一个数组或是逗号分隔的元素列表（可变参数列表），并将其转换成一个伪List Arrays.asList()输出一个伪List，因为在底层仍然是一个数组，因此不能调整其尺寸 Arrays.asList()方法的输出的List是编译器认为的最理想的类型，但是这种非人为的假设有时会有非预期的List类型 创建了snow2时，Arrays.asList()中只有Powder类型，因此它会创建List&lt;Powder&gt;而不是List&lt;Snow&gt; 在snow4的操作中，Arrays.asList()中间插入了一个显式类型参数说明(Arrays.&lt;Snow&gt;asList())，以告诉编译器产生一个List&lt;Snow&gt;的类型 Collections.addAll（静态方法）接受一个Collection对象，以及一个数组或一个用逗号分隔的列表，将元素加入Collection对象 Collection.addAll（对象成员函数）之接受另一个Collection对象 Collection的构造器可以接受另一个Collection作为入参，来构造另一个Collection对象 1Collection(Arrays.asList(1,2,3)) 11.4 容器的打印 打印函数会自动调用对象的toString()方法进行打印 HashSet、HashMap:使用了最快的元素查询的方法 LinkedHashSet、LinkedHashMap既保留了插入顺序存储，还保留了Hash的查询速度 TreeSet按照值的升序来存储，TreeMap按照键的升序来存储 11.5 List 两种类型的List ArrayList: 随机访问速度快，插入和删除元素慢 LinkedList：随机访问慢，随机插入和删除快 成员函数： List.subList():生成的子List中的元素实质上还是原来List中对象的引用 List.addAll(int index，Collection col)：重载了一个在index位置插入Collection的方法，而不仅仅是Collection.addAll()方法在表尾插入的方法 Object List.toArray()：返回的是一个Object数组，list.&lt;Integer&gt;toArray()可以显示的指定返回类型 List.remove()、List.contains()方法依赖于List中的equals()方法的实现 11.6 迭代器 Iterator只能单向移动，如果只是单向向前遍历，foreach语法更好 Iterator还可以删除有next()产生的最后一个元素，利用该方法可以在遍历过程中动态的删除，foreach语法不行 ListIterator： 可以双向移动 可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引 可以使用set()方法替换它访问过的最后一个元素 listIterator(n)方法可以创建一个一开始就指向列表索引为n的元素处的ListIterator 11.7 LinkedList LinkedList可以方便的实现栈、队列或`双端队列 11.8 Stack Stack是LIFO的容器 LinkedList已经具有了能够实现Stack所有功能的方法，因此可以直接使用LinkedList作为Stack使用 java.util中的Stack使用了继承LinkedList的实现方式，但是LinkedList的功能是大于Stack的，所以会是Stack具有LinkedList中的所有方法 采用Stack组合LinkedList对象的方式更合理 11.9 Set Set与Collection具有完全一样的接口 存储结构 TreeSet:红-黑树结构 HashSet:散列函数 LinkedHashSet:查询使用散列，插入时使用了链表 TreeSet排序规则 在生成TreeSet对象时，可以在传入排序规则参数 1new TreeSet&lt;String&gt;(String.CASE_INSENTIVE_ORDER); 11.10 Map Java之HashMap.values()方法误用 12345678910111213141516171819package collections;import java.util.HashMap;import java.util.List;import java.util.Map;public class Test &#123; /** * @param args */ public static void main(String[] args) &#123; Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); map.put(\"A\", \"A\"); map.put(\"B\", \"B\"); map.put(\"C\", \"C\"); List&lt;String&gt; valuesList = (List&lt;String&gt;) map.values(); for(String str:valuesList)&#123; System.out.println(str); &#125; &#125;&#125; 运行时候抛出异常，异常信息如下： 12Exception in thread \"main\" java.lang.ClassCastException: java.util.HashMap$Values cannot be cast to java.util.Listat collections.Test.main(Test.java:20) 原因： 首先找到了values()方法所在的源码，信息如下： 1234public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; return (vs != null ? vs : (values = new Values()));&#125; 原来values()方法只是返回了一个Collection集合，可是如程序中的用法所示，在向下转型的时候出现了类型转换错误。那我们应该怎么才能获取自己想要的结构呢？ 解决方案：在ArrayList中，有一个构造函数 1234567public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; 可以接受一个集合类型的参数，然后返回一个list；这样就达到了预期目的。 1new ArrayList&lt;String&gt;(map.values()); 11.11 Queue Queue是一种典型的FIFO的容器 队列通常被当作一种可靠的将对象从程序的某个区域传输到另一个区域的途径。队列在并发编程中特别重要，因为它可以安全的将对象从一个任务传输给另一个任务。 PriorityQueue 普通的Queue的FIFO是指下一个出队列的元素是等待时间最长的元素 PriorityQueue在调用offer()方法，插入一个元素时，这个对象首先会使用插入排序，安装自定义（Comparator对象）或者对象默认的排序规则进行插入排序。也就是说下一个出队列的元素应该是优先级最高的元素。 11.12 Collection和Iterator C++中的容器类其实并没有一个类似于Collection的类的公共基类，容器之间的所有共性都是通过迭代器实现的。 java中，把Collection的公共基类和迭代器两个方法绑定在了一起来表示容器之间的共性，因为实现Collection就意味着需要提供iterator()方法 java.util.AbstractCollection类提供了Collection的默认实现，可以继承该类，避免重复实现通用的方法 Collection接口和Iterator都可以将display()方法与底层容器的特定实现解耦 当你要给一个类实现Collection类的接口时可能非常困难，那么实现Iterator()方法以返回一个Iterator对象将容易得多。 尽管可以通过继承AbstractCollection类，但是还是要实现iterator()和size()方法，因为这两个方法是abstract的 如果你的类已经继承了一个类，那么久不能再继承AbstractCollection类了，那么此时选择实现Collection类将会更容易一些 生成Iterator是将队列与消费队列的方法连接在一起耦合度最小的方式，并且相比于实现Collection相比，它在序列类时约束也要少得多 11.13 Foreach与迭代器 所有实现了Iterable接口的类，都实现了一个能产生Iterator对象的方法，并且Iterable接口能被foreach用来在序列中移动 foreach语句可以用于数组或其他任何Iterable,但并不意味着数组肯定也是一个Iterable,而任何自动包装都不会自动发生 适配器方法惯用法 当你想在foreach语句中实现对序列容器逆序迭代时，你可以通过实现一个能够产生Iterable对象的方法，然后在hasnext()、next()和isEmpty()方法中实现逆序 MultiIterableClass就是一个适配器类，继承了一个可迭代的基类，然后再适配器类里写了两个能产生适配目标类型的适配方法 使用Arrays.asList()方法生成的List对象在其使用Coolections.shuffle()方法时，是直接对其底层的数组进行操作的；而如果是一个直接构造的ArrayList对象，使用Coolections.shuffle()方法时，只是将其引用打乱，而不是直接操作它的对象 11.14 总结 新程序中不应该过多的使用过时的Vector、HashTable、Stack Vector和Stack(已过时，不建议使用) Java容器的简图","categories":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/categories/ThinkinJava/"}],"tags":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/tags/ThinkinJava/"}]},{"title":"Thinking in Java 第十章 内部类","date":"2017-12-13T01:49:44.000Z","path":"2017/12/13/Thinking-in-Java-第十章-内部类/","text":"内部类允许吧一些逻辑相关联的类组织在一起，并控制位于内部的类的可见性 内部类了解外部类，并能与之通信；而且用内部类写出的代码更加优雅而清晰 10.1 创建内部类 内部类：把类的定义放在另一个类的内部 10.2 链接到外部类 当生成一个内部类对象时，此对象与制造它的外围对象就有一种联系，所以它能访问其外围类对象的所有成员 当通过某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密的捕获一个指向哪个外围类对象的引用。通过这个指向外部类对象的引用，就可以访问外部类的所有成员变量。 非static内部类的对象只能在与其外围类的对象相关联的情况下才能被创建，这是因为内部类对象在创建时需要一个指向其外部类对象的引用，如果编译器访问不到这个引用就会报错 10.3 使用.this和.new 在拥有外部类对象之前是不能创建内部类对象的。这是因为内部类对象会暗暗地连接到创建它的外部类对象上。 创建内部类对象方式 1Outter.Inner inner=new Outter().new Inner(); 10.4 内部类与向上转型 当一个private内部类implements了某个接口类 则该内部类只能在外部类中进行访问，外部类的对象都不能访问，因此不能通过new Outter().new Inner()这种方式来创建内部类对象 当在外部类中new了一个内部类对象，并将其关联到一个其基类（接口类）的引用，此时该内部类对象就被向上转型了，并且不能向下转型为private内部类对象，因为内部类的名称都不可见 由此，也实现了内部类的实现与外部接口的完全分离 10.5 在方法和作用域内的内部类 内部类不仅可以定义于外部类中，其他它可以在一个方法里面或者任意的作用域内定义内部类 定义于方法中的内部类 定义于作用域的类，此作用域在方法内部 一个实现了接口的匿名类 一个匿名类，它扩展了非默认构造器的类 一个匿名类，它执行字段初始化 一个匿名类，它通过实例初始化实现构造（匿名类不可能有构造器） 10.6 匿名内部类 一个实现了接口的匿名类 解释： 创建一个继承自Contents的匿名类的对象 通过new表达式返回的引用被自动向上转型为Contents的引用 相当于： 一个匿名类，它扩展了非默认构造器的类 如果基类需要一个有参数的构造器，而不是默认构造函数，只需要简单地传递合适的参数给基类构造器即可。 一个匿名类，它执行字段初始化 如果要在匿名内部类中，使用外部传入的对象（例如，利用外部对象进行内部类某些字段的初始化），那么这个外部对象必须是final的 一个匿名类，它通过实例初始化实现构造 一个匿名类不可能有命名的构造器（因为它根本没有名字） 但是通过实例初始化块，可以实现构造器的功能 实例初始化块不能重载，所以只能有一个这样的“构造器” 利用匿名内部类构造工厂模式 用于Checkers和Chess类的构造函数可以为private了，可以利用匿名的工厂类来实现生成一个Checkers对象和Chess对象 10.7 嵌套类 嵌套类：如果不需要内部类对象与其外部类对象之间有联系，可以将内部类声明为static，这就是嵌套类 普通内部类对象隐式的保存了一个引用，指向创建它的外围类对象，但是嵌套类意味着： 要创建嵌套类对象，就不需要其外围类的对象 不能从嵌套类的对象中访问非静态的外围类对象 普通的（非static）内部类不能有static数据和static字段 非静态内部类 依赖于一个外部类对象，而静态域/方法是不依赖与对象——仅与类相关 细说了，就是加载静态域时，根本没有外部类对象 因此，非静态内部类中不能定义静态域/方法，编译过不了 接口中的内部类 2.1 正常情况下，不能在接口内部放置任何代码，但嵌套类可以作为接口的一部分。因为放在接口中的任何类都自动是public static的熟悉 2.2 每个类都写一个main()函数的测试类，会在编译后的class文件中包含该部分的多余代码 如果在被测试的类中添加一个static的类用于测试外部的被测类，那么，可利用内部类的可见性进行测试，同时在编译后，该静态类会被单独编译成一个文件，就实现了测试代码与被测代码的分离 多层嵌套类可访问所以它所嵌入的外围类的所有成员 10.8 为什么需要内部类 核心原因：每个内部类都能独立地继承自一个（接口或普通类的）实现，所以无论外围类是否已经继承了某个接口（或普通类）的实现，对于内部都没有影响 接口类解决了部分的多重继承的问题，但是内部类允许继承多个非接口类型（类或者抽象类型） 如果拥有的是抽象的类或者具体的类，而不是接口，那就只能使用内部类来实现多重继承 内部类的一些特性： 一个外部类可以有有多个内部类实例，每个实例都有自己的状态信息 在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类 创建内部类对象的时刻并不依赖与外部类对象的创建 内部类没有令人迷惑的“is-a”关系，它就是一个独立的实体 闭包与回调 闭包:在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。Peter J. Landin 在1964年将术语闭包定义为一种包含环境成分和控制成分的实体。 内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向次外围类对象的引用，在此作用域内，内部类有权操作所以的成员，包括private成员 回调（callback）：通过回掉，对象能够携带一些信息，这个信息允许它在稍后的某个时刻调用初始的对象。（例如，用内部类对象回调外部类） 内部类与控制框架 应用程序框架就是用于解决特定问题的一个类或一组类 在应用框架时，通常是继承一个或多个类，然后覆盖其中的某些方法 实现控制框架的核心是：每种Event控制方法是不变的（run、addEvent），但是每个不同的Event在同一种控制方法中具体的响应又是不同的。设计的目的就是要把这种不变的控制方法与具体的变化的响应动作相互分离 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@startumlclass Controller&#123; - List&lt;Event&gt; + addEvent(Event e) + run() + &#123;static&#125; main()&#125;class GreeenHouseController&#123; + &#123;Inner Class&#125;LightOn implement Event + &#123;Inner Class&#125;LightOff implement Event + &#123;Inner Class&#125;WaterOn implement Event + &#123;Inner Class&#125;WaterOff implement Event + &#123;static&#125; main()&#125;class LightOn&#123; + action() + toString()&#125;class LightOff&#123; + action() + toString()&#125;class WaterOn&#123; + action() + toString()&#125;class WaterOff&#123; + action() + toString()&#125;abstract class Event&#123; - endTime + satrt() + ready() + &#123;abstract&#125; action()&#125;Event &lt;|-- LightOnEvent &lt;|-- LightOffEvent &lt;|-- WaterOnEvent &lt;|-- WaterOffController &lt;|-- GreeenHouseControllerGreeenHouseController *-- LightOnGreeenHouseController *-- LightOffGreeenHouseController *-- WaterOnGreeenHouseController *-- WaterOff@enduml 解读： GreeenHouseController继承了Controller，就把通用的控制方法继承了，然后再GreeenHouseController内部由LightOn、LightOff、WaterOn、WaterOff等内部类继承了Event类，并在各内部类中分别实现了不同的action方法，从而实现了相同的控制方法和不同的响应方式的控制框架类 并且，内部类可以轻易的访问外部类的成员，因此在action方法中可以任意的操作List&lt;Event&gt; 10.9 内部类的继承 因为内部类的构造器必须要连接到指向外部类对象的引用，所必需在内部类的继承类的构造器中先传入一个外部类的引用，然后使用enclosingClassReference.super()来传递一个外部类的引用 10.10 内部类可以被覆盖吗 当外部类被继承时，在子外部类中写一个父外部类中同名的内部类是不能覆盖的 123456789@startumlclass Outter&#123; + &#123;Inner Class&#125; class Inner&#123;void f()&#125;&#125;class NewOutter&#123; + &#123;Inner Class&#125; class Inner&#123;void f()&#125;&#125;Outter &lt;|-- NewOutter@endluml NewOutter中的Inner并不能覆盖Outter中的Inner 当外部类被继承时，在子外部类中生成一个内部类来继承基类中的内部类时，是可以被override的 123456789@startumlclass Outter&#123; + &#123;Inner Class&#125; class Inner&#123;void f()&#125;&#125;class NewOutter&#123; + &#123;Inner Class&#125; class Inner extends Outter.Inner&#123;void f()&#125;&#125;Outter &lt;|-- NewOutter@endluml NewOutter中的Inner能覆盖Outter中的Inner 10.11 局部内部类 在函数或其他代码块创建的内部类就是局部内部类 局部内部类不能有访问说明符(private、public…)，因为它不是外部类的一部分，但是它却可以自由访问外部类的所有成员 使用局部内部类而不使用匿名内部类的原因就是：需要不止一个该内部类的对象（匿名内部类只能用户实例初始化，局部内部类可以重载构造器） 10.12 内部类标识符 源码被编译后，每个类都会生成一个单独的.class文件，内部类也是如此。 内部类的.class文件的命名规则就是 1Outter$Inner.class 匿名内部类，编译器会简单的生成一个数字作为其标识符 1Outter$123456.class 10.13 总结Java中的内部类和接口，间接的实现了多重继承的问题","categories":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/categories/ThinkinJava/"}],"tags":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/tags/ThinkinJava/"}]},{"title":"Thinking in java 第九章 接口","date":"2017-12-12T10:07:54.000Z","path":"2017/12/12/Thinking-in-java-第九章-接口/","text":"接口和内部类为我们提供了一种将接口和实现分离的更加结构化的方法 抽象类是接口与类之间的中庸之道 9.1 抽象类和抽象方法 抽象类：包含抽象方法的类就是抽象类 如果继承一个抽象类，那么在子类中必须要实现所有的抽象方法。否则，该类仍然是一个抽象类 抽象类不能被实例化 9.2 接口 Interface产生一个完全抽象的类，不允许有任何具体方法的实现 Interface类的默认属性 接口中的所有域都是：static+final 接口中的所有方法都是：public toString方法是Object类的中的一个方法，所以任何接口类即使不显式的写该方法，也会默认的会被继承的 9.3 完全解耦 适配器模式 利用组合，将被适配的类对象放入适配器类中，并通过代理方法将其转换为目标类型 12345678910@startumlinterface Targetinterface OtherInterfaceTarget &lt;|-- Adapter : ExtensionOtherInterface &lt;|-- Adaptee : ExtensionAdapter *-- Adaptee : CompositionTarget : request()Adapter : request()Adaptee : specialRequest()@enduml 9.4 Java中的多重继承 C++的多重继承可能会带来“菱形问题”，即：在每个基类中，同一个方法都有一个自己的实现版本。而在java中，你可以避免该问题，因为java在多重继承时，只允许某个基类的接口被其中某一个类（其他基类或者子类）具体实现，除此之外，其他类不能再实现该接口。 12345678910111213141516171819202122@startumlinterface CanFight&#123; + fight()&#125;interface CanSwim&#123; + swim()&#125;interface CanFly&#123; + fly()&#125;class ActionCharacter&#123; + fight()&#125;class Hero&#123; + swim() + fly()&#125;ActionCharacter &lt;|-- Hero : ExtensionCanFight &lt;|-- Hero : ExtensionCanSwim &lt;|-- Hero : ExtensionCanFly &lt;|-- Hero : Extension@enduml ch9.4-1 可以看到hero类实现了CanSwim, CanFight, CanFly接口，同时继承了ActionCharacter类 ActionCharacter类中已经实现了fight方法，因此咋爱Hero类中就不用再实现fight方法 使用接口的核心原因： 为了能够向上转型为多个基类型，由此带来灵活性 与使用抽象基类一样，接口也可以防止客户端程序员创建该对象，并确保这仅仅是建立一个接口 9.5 通过继承来扩展接口 通过继承，可以很容易地在接口中添加新的方法声明；还可以通过继承在新接口中组合多个接口形成新的接口类 1interface I3 extends I1, I2; 通常只能extends一个类，但是可以extends多个接口类 组合接口时的名字冲突 ch9.5-1 ch9.5-2 当重载、覆盖、实现混在一起时，重载方法仅通过返回值类型是区分不开的。所以，打算组合的不同接口中使用了相同的方法名通常会造成代码可读性混乱。 9.6 适配接口 策略设计模式： 编写一个方法时，该方法的入参不用具体类，而是写一个接口类型；由此就实现了“你可以用任何你想要的对象来调用我的方法，只要你遵循我的接口” 而任何类都可以通过适配器模式将其转换为方法调用的入参类型，所以使用接口类型作为入参，灵活性很高 9.7 接口中的域 接口中的成员变量默认都是static和final的属性，且接口中所以的域都是public的，所以可以利用interface作为常量组工具 接口中域（final static）必须要定义时初始化，且可以利用非常量表达式对其进行初始化。 ch9.7-1 9.8 嵌套接口 接口类可以被嵌套在普通类和接口类里面 在class内部，嵌套的interface可以声明为private 在interface内部，嵌套的interface只能声明为public private的嵌套接口： 能在内部实现该private接口的一个private内部类，也能被实现private接口的一个public的内部类 在内部类中利用public方法返回一个private接口的引用时，他的返回值不能直接给其他内部对象的引用。只能将返回值交给有权使用它的外部对象 ch9.8-2 9.9 接口与工厂 工厂模式 1234567891011121314151617181920@startumlinterface Serviceinterface Factory&#123; - Service&#125;class ServiceAclass ServiceBclass FactoryA&#123; + ServiceA:createServiceA()&#125;class FactoryB&#123; + ServiceB:createServiceB()&#125;Service &lt;|-- ServiceA : ExtensionService &lt;|-- ServiceB : ExtensionFactory &lt;|-- FactoryA : ExtensionFactory &lt;|-- FactoryB : Extension@enduml 9.10 总结 创建类，几乎在任何时刻，都可以替代为创建一个接口和一个工厂 不能因为意识到由于以防万一而添加接口，应当从类开始，如果接口的必需性变得非常明确后，就进行重构","categories":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/categories/ThinkinJava/"}],"tags":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/tags/ThinkinJava/"}]},{"title":"Thinking in Java 第八章 多态","date":"2017-12-11T11:08:16.000Z","path":"2017/12/11/Thinking-in-Java-第八章-多态/","text":"8.1 再论向上转型 利用向上转型，在编写函数时，只针对基类的接口编程，可以大幅度减少通过函数重载实现的功能 8.2 转机 方法调用绑定：将一个方法调用(tune)与方法主体(Instrument)关联起来被称作绑定。 123public static void tune(Instrument i)&#123; i.play(Note.MIDDLE_C);&#125; 前期绑定（编译多态）：Java中的static方法和final方法（private方法属于final方法）都是前期绑定 后期绑定（运行时多态）：在运行时根据对象类型进行绑定 除了static方法和final/private方法，其他都是后期绑定。 final方法虽然因为使用前期绑定可以生成更有效的代码，但绝不能为了试图提高性能而使用final，要根据设计来决定是否使用final 多态的缺陷：“覆盖”私有方法 只有非private方法才可以被覆盖 在子类中写一个与父类中某个priavte方法同名的方法不是override，而是一个全新的函数，由此在（多态）向上转型时会发生意料之外的情况 多态的缺陷：域与静态方法 一个类中只有普通的方法才是多态的，static方法和域（成员变量）都不是多态的 基类和子类如果有同名，同类型的变量，那么方法调用的引用是什么类型，就得到那个类型的变量值，不能实现成员变量的多态 同样，静态方法是属于类的，而不属于对象，所以不能实现多态 8.3 构造器和多态 构造器的调用顺序 调用基类构造器（继承） 按声明顺序调用成员变量的初始化方法（组合） 调用当前子类的构造器 这种顺序的原因是：当进行继承时，我们已经知道了基类的一切，并可以访问基类中任何声明为public和protected的成员。这就意味着在子类中，必须假定基类的所有成员都是有效的，所以要先初始化基类。 清理顺序 当前类的成员变量 基类类的dispose函数 基类的成员变量 ….. 2.1 如果某个子对象依赖于其他对象（组合），销毁的顺序应与变量的声明顺序相反。 2.2 应该首先对子类进行清理，然后才是基类，因为在清理子类的时候可能还会需要调用基类的某些方法，所以基类应该在子类之后进行销毁 构造器内部的堕胎方法的行为 结构：在基类构造器正在被执行的过程中，在基类构造器中调用了某个在子类中已经被override的方法。 case：在上述结构的类中，一旦子类在进行构造时，会先调用基类的构造器。此时，基类构造器中的多态方法就会被调用，但是此时子类并没有构造完成，所以这时候由于多态的原因，子类中的方法就会被调用，但是子类方法一旦涉及到子类的其他未初始化的成员变量，就会导致行为不可预测。 tips：用尽可能简单的方法使对象进入正常状态，尽可能的避免调用其它方法。在构造器内能够安全调用的只有final/private方法（因为他们不会有多态的问题） 8.4 协变返回类型在子类中override某个基类方法时，可以返回该基类方法返回类型的某种子类类型 ch8.4-1 8.5 用继承进行设计 一条通用的准则是：用继承表达行为间的差异，用字段（组合）表达状态上的变化 纯继承和扩展 纯继承：“is-a”关系，即：子类与基类有完全一样的接口 扩展：”is-like-a”关系，即：子类在基类的基础上进行接口扩展 向下转型 子类扩展就带来了向下转型时的需求，向下转型就需要显式的对基类对象进行转型 java对所有转型都会进行类型检查，在进入运行期后仍然会对其进行期类型检查（RTTI），如果实际类型与检查结果不符合，就会返回一个ClassCastException","categories":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/categories/ThinkinJava/"}],"tags":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/tags/ThinkinJava/"}]},{"title":"Thinking in Java 第七章 复用类","date":"2017-12-05T13:11:52.000Z","path":"2017/12/05/Thinking-in-Java-第七章-复用类/","text":"复用：由现有类的对象所组成，该方法只复用了nc现有程序代码的功能，而非它的形式 继承：按照现有类创建新类。它无需改变现有类的形式，采用现有类的形式并在其中添加新代码 7.1 组合语法 组合中各个非基本类型的引用需要初始化，其初始化的位置可以为： 在定义对象的时候就初始化，这样会使该类的每个对象中的该引用都有一个默认的值 在类构造器中 在使用这些对象之前初始化，即“惰性初始化” 使用实例进行初始化 12345678910@startumlclass Wing &#123;&#125;class Bird &#123;-Wing:wing+method3()+method4()&#125;Bird *-- Wing:Composition@enduml 7.2 继承语法 Java用super关键字表示基类的意思，super.func()表示调用基类中的func() Java会在子类的构造器中自动插入对基类构造器的调用 子类对象在构造时，是从基类开始构造 如果基类没有默认构造器（不带参构造器），或者想调用一个带参数构造器，就必须用关键字super显式的调用基类构造器，其调用基类构造器的语句必须位于构造器的第一行。 123456789101112131415@startumlclass Base &#123;-field1-field2+method1()+method2()&#125;class Child &#123;-field3-field4+method3()+method4()&#125;Base &lt;|-- Child:Extension@enduml 7.3 代理 java并没有提供对代理的直接支持，它介于组合与继承之间 将一个成员对象的引用放在一个另一个新类中（组合），并在这个新类中将成员对象的方法暴露出来（就像继承） 123456789101112@startumlclass SpaceshipControl &#123; + up() + down()&#125;class Spaceship &#123; -SpaceshipControl:ssc +up()&#123;ssc.up()&#125; +down()&#123;ssc.down()&#125;&#125;Spaceship *-- SpaceshipControl:Agent@enduml 使用代理时还可以选择只暴露成员对象中的某些方法，而不一定是全部的方法。 7.4 结合使用组合和继承 无论try块怎样退出，保护区后的finally子句中代码一定会执行的e 基类和子类的初始化顺序是：先基类后子类 而析构正好与之相反：先析构子类，再析构父类。 原因：防止某个子对象依赖于另一个对象的情形发生 名称屏蔽 如果Java的基类中有n个重载的方法，在其子类中还可以继续重载该方法（即参数列表不一样），而这在C++中，在子类中，基类的同名函数将会被屏蔽 @Override 必须要求覆写的方法具有相同的特征签名，由此可以防止意外的重载 7.5 在组合和继承之间选择 组合： 用于在新类中使用现有类的功能而非它的接口 通常在组合时，会把被组合的现有类声明为private（因为需要屏蔽底层实现），但是有的时候，组合中的现有类对象也是问题分析的以部分（而不仅仅是底层设计的一部分），将其声明为public有助于客户端程序员理解怎么样去使用类。但这都是特例。 继承 在一个通用类的基础上，为了某种特殊需求而将其特殊化 继承就是“is-a”关系，组合就是“has a”关系 7.6 protected关键字 基类的protected域可以在子类中访问，但在基类，子类的对象中都不可以访问 尽管可以创建protected域，但是还是最好将域保持为private，你应当一直保留“更改底层实现”的权利。然后通过protected方法来控制类的继承者的访问权限 7.7 向上转型 “为新类提供新的方法”并不是基础技术中最重要的作用，其最重要的作用是用来表现心累和基类之间的关系。这种关系可以描述为“新类型是现有类的一种类型”，因此，向上转型是从一个比较专用的类型向通用类型转换，所以总是安全的。 再论组合和继承 到底使用组合还是继承，一个最清晰的判断方法就是：问问自己是否需要从新类型向基类进行向上转型。如果必须向上转型，则继承是必要的 7.8 final关键字 使用final意味着“这是无法改变的”。不想做改变可能出于两种原因：设计或效率 final数据： 目的： 一个永不改变的编译时常量 一个既是static又是final的域就是一个编译器常量 一个在运行时才被初始化，而一旦初始化后就不再改变 作用： final对基本数据类型使用时，final使得其变量数值恒定不变 final对对象使用时，只能使引用为恒定不变的，但是被引用所对应的对象内部仍然是可以被改变的。即：指针常量 空白final： 空白final是指被声明为final，但又未给其初值的域。但是无论什么情况，编译器都要确保该空白final变量在被使用前已经被初始化 这种“确保”是通过在域的定义处或者每个构造器中使用表达式对其赋值的 final参数：函数中的参数被声明为final时，在函数内部只可以读，不可以改变其值（引用）。这一特性主要用来向匿名内部类传递数据？？？？ final方法 目的： 把方法锁定，以防止继承类修改它的含义 确保final方法在继承类中行为不变，并且不会被覆盖 作用： 过去，java会将final方法编译优化为内嵌代码，这可能带来代码膨胀的问题；但是现在编译器会自动检查代码是否需要内嵌，所以使用final方法将没有意义 所有private方法都隐式的指定为final，无法取用private方法，所以也就无法在子类中覆盖它 覆盖只对基类的接口部分（public &amp; protected）有作用；所以在基类和子类中写同样的private函数，其实并不是覆盖，只是单纯的同名的函数而已 final类 当类定义为final时，该类就不可以继承 关于final的忠告 将某个域设置为final，即表明其将不能被覆盖或继承。但这种对使用者对类的使用方式的预见是及其困难的。因此，何时用final这一问题，涉及到程序员无法正确猜测优化应当发生在何处的问题。 7.9 初始化及类的加载 在C++中，如果一个static的变量初始化需要依赖另一个static变量时，就可能出现问题，因为此时另一个static变量可能还未初始化 java就不会出现该问题。 因为java中所有的事物都是对象，每个类的编译代码都在一个独立的文件中，该文件只在需要使用程序代码时才会被加载。 类的代码在初次使用时才加载。通常是指加载发生于创建类的第一个对象之时；当访问static域或static方法时，也会发生加载 类在加载和初始化时，基本对象被默认为0，对象引用设为null，这是通过将对象内存设为二进制的零值而一举产生的。 继承与初始化 父类static域（方法）–&gt;子类static域（方法）–&gt;父类构造器–&gt;子类构造器","categories":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/categories/ThinkinJava/"}],"tags":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/tags/ThinkinJava/"}]},{"title":"神经网络和深度学习-第二章 神经网络基础","date":"2017-12-04T10:47:58.000Z","path":"2017/12/04/神经网络和深度学习-第二章-神经网络基础/","text":"Chapter2：神经网络基础二分分类 如Cat vs No-Cat问题，目标是训练一个分类器，输入是一张图片，图片被表示成一个特征向量x，并且预测标签y是1（Cat)还是0（No-Cat）。 吴恩达的矩阵表示法：用列向量表示一个样本，因此 X.shape==(n_x,m)，n_x表示特征数，m是样本大小。 ch2.1.cat](http://upload-images.jianshu.io/upload_images/4905573-6fd32189efefa94c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![ch2.1.n_x logistic回归 logistic回归是一种监督学习下的学习算法，使得输出y要么都是0或者要么都是1。logistic回归的目标是使预测和训练数据之间的误差最小化。 对于Cat vs No-Cat问题，给定一张图的特征向量 x，这个算法将会评估这幅图是猫的概率： ch2.2.P*(cat)](http://upload-images.jianshu.io/upload_images/4905573-6f1a2bd727f6a2ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![ch2.2.Sigmoid function 通过计算，W^Tx+b是一个线性函数ax+b（W^T计算出来是一个具体的数值a），因为我们期待一个在[0,1]区间的概率约束，所以sigmoid函数被使用。 sigmoid函数的性质： ch2.2.sigmoid function property logistic回归的损失函数 概念 损失函数 Loss：单个样本的估计值与真实值的误差。 成本函数 Cost：所有样本的误差总和的平均值。 ch2.3.loss function & cost function 目标函数、损失函数、代价函数有什么区别 首先给出结论：损失函数和代价函数是同一个东西，目标函数是一个与他们相关但更广的概念，对于目标函数来说在有约束条件下的最小化就是损失函数（loss function）。举个例子解释一下:（图片来自Andrew Ng Machine Learning公开课视频） function_pics 上面三个图的函数依次为 f1(x)](https://www.zhihu.com/equation?tex=f_%7B1%7D%28x%29),![f2(x)](https://www.zhihu.com/equation?tex=f_%7B2%7D%28x%29),![f3(x)](https://www.zhihu.com/equation?tex=f_%7B3%7D%28x%29)。我们是想用这三个函数分别来拟合Price，Price的真实值记为![Y 。 我们给定 function)，或者叫代价函数(cost 。损失函数越小，就代表模型拟合的越好。 那是不是我们的目标就只是让loss function越小越好呢？还不是。 这个时候还有一个概念叫风险函数(risk function)。风险函数是损失函数的期望，这是由于我们输入输出的 (X,Y)](https://www.zhihu.com/equation?tex=%28X%2CY%29)遵循一个联合分布，但是这个联合分布是未知的，所以无法计算。但是我们是有历史数据的，就是我们的训练集，![f(X)](https://www.zhihu.com/equation?tex=f%28X%29)关于训练集的平均损失称作经验风险(empirical risk)，即![empirical risk](https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%3D1%7D%5E%7BN%7DL%28y_%7Bi%7D%2Cf%28x_%7Bi%7D%29%29)，所以我们的目标就是最小化![empirical risk ，称为经验风险最小化。到这里完了吗？还没有。 如果到这一步就完了的话，那我们看上面的图，那肯定是最右面的 f3(x)](https://www.zhihu.com/equation?tex=f_%7B3%7D%28x%29)的经验风险函数最小了，因为它对历史的数据拟合的最好嘛。但是我们从图上来看![f3(x) 。 为什么会造成这种结果？大白话说就是它的函数太复杂了，都有四次方了，这就引出了下面的概念，我们不仅要让经验风险最小化，还要让结构风险最小化。这个时候就定义了一个函数 J(f)](https://www.zhihu.com/equation?tex=J%28f%29)，这个函数专门用来**度量模型的复杂度**，在机器学习中也叫正则化(regularization)。常用的有![L1](https://www.zhihu.com/equation?tex=L_1),![L2](https://www.zhihu.com/equation?tex=L_2)范数。到这一步我们就可以说我们最终的优化函数是：![target function ，即最优化经验风险和结构风险，而这个函数就被称为目标函数。 结合上面的例子来分析：最左面的 f1(x)](https://www.zhihu.com/equation?tex=f_%7B1%7D%28x%29)结构风险最小（模型结构最简单），但是经验风险最大（对历史数据拟合的最差）；最右面的![f3(x)](https://www.zhihu.com/equation?tex=f_%7B3%7D%28x%29)经验风险最小（对历史数据拟合的最好），但是结构风险最大（模型结构最复杂）;而![f2(x) 达到了二者的良好平衡，最适合用来预测未知数据集。以上的理解基于Coursera上Andrew Ng的公开课和李航的《统计学习方法》,如有理解错误。 梯度下降法 我们已经掌握了Cost function的表达式，接下来将使用梯度下降（Gradient Descent）算法来计算出合适的w和b值，从而最小化m个训练样本的Cost function，即J(w,b)。 由于J(w,b)是convex function，梯度下降算法是先随机选择一组参数w和b值，然后每次迭代的过程中分别沿着w和b的梯度（偏导数）的反方向前进一小步，不断修正w和b。每次迭代更新w和b后，都能让J(w,b)更接近全局最小值。梯度下降的过程如下图所示。 ch2.4.Gradient Descent 梯度下降算法每次迭代更新，w和b的修正表达式为： $$w:=w-\\partial \\frac{\\partial J(w,b))}{\\partial w}$$ $$b:b-\\partial \\frac{\\partial J(w,b))}{\\partial b}$$ 上式中，$α$是学习因子（learning rate），表示梯度下降的步进长度。$α$大，$w$和$b$每次更新的“步伐”更大一些；$α$越小，$w$和$b$每次更新的“步伐”更小一些。在程序代码中，我们通常使用$dw$来表示$\\frac{\\partial J(w,b))}{\\partial w}$，用$db$来表示$\\frac{\\partial J(w,b))}{\\partial b}$。微积分里，$\\frac{df}{dx}$表示对单一变量求导数，$\\frac{\\partial f}{\\partial x}$表示对多个变量中某个变量求偏导数。 梯度下降算法能够保证每次迭代w和b都能向着$J(w,b)$全局最小化的方向进行。 Derivatives 这一部分的内容非常简单，Andrew主要是给对微积分、求导数不太清楚的同学介绍的。梯度或者导数一定程度上可以看成是斜率。关于求导数的方法这里就不再赘述了。 More Derivative Examples Andrew给出了更加复杂的求导数的例子，略 Computation graph 整个神经网络的训练过程实际上包含了两个过程：正向传播（Forward Propagation）和反向传播（Back Propagation）。正向传播是从输入到输出，由神经网络计算得到预测输出的过程；反向传播是从输出到输入，对参数$w$和$b$计算梯度的过程。下面，我们用计算图（Computation graph）的形式来理解这两个过程。 举个简单的例子，假如Cost function为$J(a,b,c)=3(a+bc)$，包含$a$，$b$，$c$三个变量。我们用$u$表示$bc$，$v$表示$a+u$，则$J=3v$。它的计算图可以写成如下图所示： 令$a=5$，$b=3$，$c=2$，则$u=bc=6$，$v=a+u=11$，$J=3v=33$。计算图中，这种从左到右，从输入到输出的过程就对应着神经网络或者逻辑回归中输入与权重经过运算计算得到Cost function的正向过程。 Derivatives with a Computation Graph 上一部分介绍的是计算图的正向传播（Forward Propagation），下面我们来介绍其反向传播（Back Propagation），即计算输出对输入的偏导数。 还是上个计算图的例子，输入参数有3个，分别是a，b，c。 首先计算J对参数a的偏导数。从计算图上来看，从右到左，J是v的函数，v是a的函数。则利用求导技巧，可以得到： $$\\frac{\\partial J}{\\partial a}=\\frac{\\partial J}{\\partial v}\\cdot \\frac{\\partial v}{\\partial a}=3\\cdot 1=3$$ 根据这种思想，然后计算$J$对参数$b$的偏导数。从计算图上来看，从右到左，$J$是$v$的函数，$v$是$u$的函数，$u$是$b$的函数。可以推导： $$\\frac{\\partial J}{\\partial b}=\\frac{\\partial J}{\\partial v}\\cdot \\frac{\\partial v}{\\partial u}\\cdot \\frac{\\partial u}{\\partial b}=3\\cdot 1\\cdot c=3\\cdot 1\\cdot 2=6$$ 最后计算$J$对参数$c$的偏导数。仍从计算图上来看，从右到左，$J$是$v$的函数，$v$是$u$的函数，$u$是$c$的函数。可以推导： $$\\frac{\\partial J}{\\partial c}=\\frac{\\partial J}{\\partial v}\\cdot \\frac{\\partial v}{\\partial u}\\cdot \\frac{\\partial u}{\\partial c}=3\\cdot 1\\cdot b=3\\cdot 1\\cdot 3=9$$ 为了统一格式，在程序代码中，我们使用$da$，$db$，$dc$来表示$J$对参数$a$，$b$，$c$的偏导数。","categories":[{"name":"神经网络和深度学习","slug":"神经网络和深度学习","permalink":"http://matlabchina.cn/categories/神经网络和深度学习/"}],"tags":[{"name":"神经网络和深度学习","slug":"神经网络和深度学习","permalink":"http://matlabchina.cn/tags/神经网络和深度学习/"},{"name":"公开课","slug":"公开课","permalink":"http://matlabchina.cn/tags/公开课/"}]},{"title":"知乎--彼得·林奇（Peter Lynch）的投资特点是什么？","date":"2017-11-27T12:15:44.000Z","path":"2017/11/27/知乎-彼得·林奇（Peter-Lynch）的投资特点是什么？/","text":"前言1. 前言：机构有投资局限 在彼得‧林奇看来，专业投资者不得不分散投资于许多只股票。而业余投资者可以集中投资少数股票。如果一时找不到好的股票， 归结为三点来说明这位大师的投资三味： 投资你了解的； 坚定地持有； 做好功课。 2. 投资你了解的 选股既是一门科学，又是一门艺术，但是过于强调其中任何一方面都是非常危险的。” 科学：林奇在对股票价格是否合理的判断上，有个独门秘籍——PEG指标。也就是市盈率（P/E）／企业利润增长率（Growth）。PEG是彼得林奇用于评估成长型公司的方法，总体上可以分为四档: “千万不要买任何无法用笔将公司业务简单描述清楚的股票” 艺术：艺术来源生活，高于生活“。在选股方面，我们其实也可以这么说，“牛股来源于生活，高于生活”。 林奇发现了一个投资技巧，那就是购买一个股票前，先问问自己是否喜欢他们家的产品，是否认可他们家的产品。彼得林奇选择消费行业牛股的秘籍就在于逛街。 3. 坚定持有 投资股票就像找对象，都是为了能长久的在一起。没人找对象是为了离婚。因此，如果一开始就做出了明智的选择，就坚持下去，不要轻易放弃。 “当你选中了一个好的股票，那么时间就是最大的趋势。如果你选择了一个问题股，那么时间就是最大的敌人。” 4. 做好功课 不管是投资自己了解的，还是坚定的持有，本质上都需要投资者做好功课。股票投资本就是一场信息战争，谁掌握了更多的信息，有效处理了更多信息，谁就具备更多战胜市场的可能性。 “你自己不对上市公司进行调查研究，进行仔细的基本面分析，那么拥有再多的股票软件和信息服务系统也没有用。” Reference1. https://www.zhihu.com/question/19651506","categories":[{"name":"投资","slug":"投资","permalink":"http://matlabchina.cn/categories/投资/"}],"tags":[{"name":"知乎","slug":"知乎","permalink":"http://matlabchina.cn/tags/知乎/"},{"name":"投资","slug":"投资","permalink":"http://matlabchina.cn/tags/投资/"}]},{"title":"Thinking in Java 第六章 访问权限控制","date":"2017-11-23T09:27:24.000Z","path":"2017/11/23/Thinking-in-Java-第六章-访问权限控制/","text":"6.1 包：库单元 访问权限等级由大到小： public&gt;protected&gt;包访问权限&gt;private 编译单元：一个.java文件 每个编译单元都必须有一个后缀名.java 每个编译单元只有一个public类，该类的名称必须与文件的名称相同 编译单位的非public的其他类，在包外是不可见的 package语句必须放在文件除注释以外的第一行 java包的命名规则全部使用小写，包括中间字母 package命名规则： Internet域名的反序（因为Internet域名保证了包名的唯一性） class加载时搜索.class文件的机制： 首先，从CLASSPATH环境变量下的路径作为基路径开始 在基路径下开始按包名进行路径搜索 静态导入：import static org.xx.xx 使用静态导入可以使被导入类的静态变量和静态方法在当前类直接可见，使用这些静态成员无需再给出他们的类名。 6.2 Java访问权限修饰符 包访问权限 如果不提供任何访问权限修饰符，则意味着它是“包访问权限” 包访问权限意味着：当前包中所有其他类对那个成员都有访问权限；但对于包外的所有类，这个成员时private的 public 如果不给一个类指明特定的包名，则该类将位于默认包下 private 除了包含该成员的类之外，其他任何类型都无法访问这个成员 protected 本类、子类和同一包的类的方法可以访问protected成员 summary 作用域 当前类 同一包（package） 子孙类 其他包 public √ √ √ √ protected √ √ √ × default(包) √ √ × × private √ × × × 6.3 接口和实现 访问权限的控制实现了“封装”： 访问权限的控制设定了客户端程序员可以使用和不可以使用的界限，可以将客户端程序与工具类的具体实现(eg:private)解耦；但仍然在客户端可使用的接口部分，实现与接口耦合在一起的 利用接口interface可以将对外所停供的服务与实现逻辑进一步的解耦 6.4 类的访问权限 每个编译单元（文件）都只能有一个public类，这表示，每个编译单元只有一个公共的接口 public类的名称必须与文件名相同 编译单元内可以没有一个public类 类既不可以是private的（这样会使得除该类之外，其他任何类都不可以访问它），如果不希望其他任何人访问该类，可以把构造器指定为private 类也不可以是protected的：（内部类可以是private和protected） 对于顶级类(外部类)来说，只有两种修饰符：public和默认(default)。因为外部类的上一单元是包，所以外部类只有两个作用域：同包，任何位置。因此，只需要两种控制权限：包控制权限和公开访问权限，也就对应两种控制修饰符：public和默认(default)。 如果类使用了private修饰符，说明是个内部类。内部类的上一级是外部类，那么对应的有四种访问控制修饰符：本类(private)，同包(default)，父子类(protected)，任何位置(public)。当一个内部类使用了private修饰后，只能在该类的外部类内部使用。 上面这些都是平时使用司空见惯的，但是为什么是这种情况呢？ 可以想一下，一个java项目是不可能在一个class里面完成的。mvc模式中，是把类分为三层，一层层调用类。如果定义为私有的和受保护的就无法调用。换句话说，对于一个java文件，要么就是自己单独运行，要么就是被其他程序作为库调用，如果一个java文件的类被private修饰，那么是不是其他的程序或是类是无法使用它的，那么他作为一个单独的文件就没啥用了。如果它作为单个文件运行，类加载怎么找到它呢，因为它对外不可见。同时，也失去了类的存在意义。因此，类只有public和默认修饰符。 类的访问权限只能是：public和包权限","categories":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/categories/ThinkinJava/"}],"tags":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/tags/ThinkinJava/"}]},{"title":"Thinking in Java 第五章 初始化与清理","date":"2017-11-23T08:37:23.000Z","path":"2017/11/23/Thinking-in-Java-第五章-初始化与清理/","text":"5.2 方法重载 区分重载方法： 规则：每个重载的方法都必须有一个独一无二的参数类型列表（甚至参数顺序的不同也足以区分两个方法） 涉及基本类型的重载 基本类型能从一个“较小”的类型自动提示至一个“较大”的类型，此过程一旦牵涉到重载，可能会造成一些混淆 如果传入的数据类型(实际参数类型)小于方法中声明的形式参数类型，实际数据类型就会被提升，char类型会被提升为int类型；相反，如果传入参数的数据类型过大，则会窄化处理 返回值类型是不能作为重载的区分规则的 5.3 默认构造函数 如果已经定义了一个构造器，编译器就不会帮你自动创建默认构造函数 5.4 this关键字 this关键字就是表示：当前调用该方法的那个对象的引用 编译器会暗自把“所操作对象的引用（即this）”作为第一个参数传给被调用方法 eg: 1234Banana a=new Banana();Banana b=new Banana();Banana.peel(1);----&gt;Banana.peel(a,1);----&gt;Banana.peel(this,1);Banana.peel(2);----&gt;Banana.peel(b,2);----&gt;Banana.peel(this,2); 在构造器中调用构造器： 利用this可实现在构造器中调用其它的构造器 尽管this可以调用构造器，但是却不能调用两个 必须将构造器调用置于最起始处，否则编译器会报错，类似于super的用法 除构造器之外，编译器禁止在其他任何方法中调用构造器 eg： static的含义 static方法就是没有this的方法 static方法的内部不能调用非static方法，而非static方法可以调用static方法： 但是可以将对象的应用传入static方法，然后在static方法内部通过该引用调用非static方法 在没有创建任何对象的情况下可以调用static方法 5.5 清理：终结处理和垃圾回收 垃圾回收只负责释放经由new分配的内存，某些特殊分配的内存（eg：本地方法使用C/C++的malloc方法分配的内存）则无法使用垃圾回收器进行回收，而这些特殊分配的内存可以使用finalize()方法进行回收 finalize()方法： 原理：一旦垃圾回收器准备释放对象占用的存储空间时，首先会调用其finalize()方法，但是它会在下一次垃圾回收动作发生时才会真正的回收对象占用的内存 finalize（）方法与c++的析构函数不一样： java对象可能不被垃圾回收：只要程序没有濒临存储空间耗尽的情况，垃圾回收就不会发生，因为垃圾回事也是有开销的 垃圾回收并不等于析构：C++的对象一定要被销毁的（如果程序没有缺陷的话） 垃圾回收至于内存有关：之所以要有finalize()，是由于在分配内存时可能采用了类似于C语言中的做法，而非java中的通常做法。这种情况主要发生在使用“本地方法”时。 本地方法是一种在java中调用非java代码的方式，本地方法目前只支持C/C++，但它们又可能调用其它语言写的代码 终结条件： 通常，要完成类似于C++析构函数的功能时，必须显示的写一些普通方法，然后显示的调用这些方法，而不能依靠finalize()方法（以为该方法不一定会被调用）。所以finalize()方法的一个比较晦涩的用法是：用于在垃圾回收前做一些验证，验证其对象是否被正确的使用了等等。 垃圾回收器如何工作 Java内存分配与C++的区别：java采用传送带流水线的方式直接在堆上分配内存，因为是依次连续向前分配，所以分配的速度和C++在栈上分配内存的速度差不多（C++上的栈也是连续分配的）； 但是这里有一个问题，要保证java的内存连续分配，需要不断的整理内存，使其紧凑排列，其空余的可分配内存始终大致的位于堆指针的附近，同时也尽量避免了页错误。 因此内存整理的速度（垃圾回收的速度）就直接的影响到了对象的创建的速度 java的垃圾回收机制：参考其他垃圾回收机制：C++中的智能指针会在对象的引用计数为0时进行垃圾回收，这个方法也存在缺陷，一旦对象存在循环引用，则可能无法被回收 一些更快的垃圾回收机制的思想是：对任何“活”的对象，一定能最终追溯到期存活的堆栈或静态存储区之中的引用。这个引用链条可能会穿过数个对象的层次。由此，如果从堆栈和静态存储区开始，遍历所以引用，就能找到所以“活”的对象。对于发现的每个引用，必须追踪它所引用的对象，然后是此对象包含的所以引用，如此反复进行，直到“根源于堆栈和静态存储区的引用”所形成的网络全部被访问为止。你所访问过的对象都是“活”的。这样，就解决了所谓“交叉引用”的问题，因为你根本就访问不到他们。 自适应垃圾回收技术： 停止-复制：暂停程序—&gt;将存活的对象从当前堆复制到另一个堆，没有被复制的全部是垃圾。当对象被复制到新堆时，他们是一个挨着一个的，所以保持了新堆的紧凑 (1). 当把对象从一处搬到另一处时，所有指向它的引用都必须修正，静态区和堆的引用可以直接被修正，但是可能还有其他的一些引用，需要在遍历中才能被找到。 (2). 复制需要消耗比实际需求大一倍的空间 (3). 程序进入稳定状态后，只有少量垃圾需要被清理，每次都复制，效率太低 标记-清扫：从栈和静态存储区出发，遍历所有引用，进而找出所有存活的对象。每当它找到一个存活的对象，就会给对象设一个标记。在这个过程中不会回收任何对象。只有全部标记工作完成，才会开始清理那些没有被标记过的对象。 (1). 只有没被标记过的对象才能清理，因此剩下的堆空间就不是连续的了，因此还是需要再次进行整理 java虚拟机中，内存分配以较大的“块”为单位。 (1). “停止-复制”时，复制到新的内存时，可以往被废弃的块中拷贝对象 (2). 每个块都有“代数”来记录其是否还存活，被引用一次代数加1；每次GC发生时，大型对象不会被复制，只是其代数会增加，而内含小型对象的那些块则被复制并整理 (3). java虚拟机会进行监视，如果所有对象很稳定，垃圾回收器效率降低的话，就会切换到“标记-清扫”模式 JIT：即时编译技术 把程序全部或者部分的代码翻译成本地机器码（这本来是java虚拟机的工作），程序的运行速度得以提升 当需要装载某个类时，编译器会先找到其.class文件，然后将该类的字节码装入内存。此时就有两种方案可选择： (1). 让JIT编译器编译所有代码，但其存在两个缺陷： 加载动作发生在整个程序生命周期，累加起来需要更多时间 增加了可执行代码的长度（字节码长度远小于机器码），这将导致页面调度，从而降低程序的速度 (2). 惰性评估：JIT编译器只在必要时才编译代码，不会被执行的代码压根就不会被编译。Hotspot技术就是代码每次被执行时都会做一些优化，所以执行次数越多，它的速度就越快。 5.6 成员初始化 即使不显式的初始化类中的基本数据类型的数据成员，他们也会被编译器自动将其初始化为0 而类的对象引用则不会将其初始化，此引用就会获得一个null 类中的每个数据成员，可以在其定义的地方直接对其初始化（C++不能这样做），这样的话，该类的每个对象中被初始化过的数据成员都将会有一个默认的初始值 12345678eg:public class InitialValues&#123; boolean bool=true; char ch='x'; int i= f(); int f()&#123; return 1;&#125; 5.7 构造器初始化 初始化顺序：自动初始化（编译器默认赋值）—&gt;定义时初始化初值—&gt;构造器初始化 定义时初始化初值初始化顺序： 变量定义的先后顺序决定了初始化的顺序 静态对象（或静态块）初始化早于类内的其他非静态对象 静态初始化只有Class对象首次加载时进行一次 非静态块也早于构造函数 静态块 eg： 123456public class Spoon&#123; static int i;static &#123;i=47;&#125;&#125; 这段代码只执行一次：当首次生成这个类的一个对象时，或者首次访问属于那个类的数据成员时 非静态块eg： 12345678910public class Mugs&#123;Mug mug1;Mug mug2;&#123;mug1=new Mug(1);mug2=new Mug(2);&#125;public Mugs()&#123;&#125;&#125; 先执行非静态块，再执行构造器 5.8 数组初始化 所有数组（无论它们的元素是对象还是基本类型）都是一个固有成员，可以通过它获知数组内包含了多少个元素，但不能对其修改，这个成员就是length 尽管创建的是基本数据类型，new一个基本类型数组仍然可以工作，不能new单个基本类型数据 12eg：new [] int; 如果你创建了一个非基本类型的数组，那么你就创建了一个引用数组 数组初始化的两种方式： Integer [] a={new Integer(1); new Integer(2); 3}; Integer [] b=new Integer[]{new Integer(1); new Integer(2), };//列表最后一个逗号是可选的 可变参数列表： 1public void func(int... args)&#123;&#125; 调用该函数时你可以传一个数组给它，或者直接依次写多个同类型参数给它 可变参数列表的函数会自动给需要装包的变量进行装包 编译器会使用自动装包机制来匹配重载的方法，然后调用最明确匹配的方法 自动装包机制同时也会使重载变得复杂 123eg: public void func(int... args); public void func(Integer... args); 5.9 枚举类型 枚举实际是一个类，并且具有自己的方法 枚举类型的实例都是常量 创建枚举时，编译器会自动添加一些特性： toString()：序列化枚举对象 ordinal()：表示某个特定enum常量的声明顺序 values():按照enum常量的声明顺序，产生由这些常量值构成的数组","categories":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/categories/ThinkinJava/"}],"tags":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/tags/ThinkinJava/"}]},{"title":"Thinking in Java 第四章 控制执行流程","date":"2017-11-22T11:32:48.000Z","path":"2017/11/22/Thinking-in-Java-第四章 控制执行流程/","text":"4.1 true和false java不允许将一个数字作为boolean值使用 4.3.3 逗号操作符 区别于逗号操作符（用于分隔函数参数），java里唯一用到逗号操作符的就是for语句中的初始化和步进控制部分： 通过使用逗号操作符，可以在for语句中定义多个变量，但是必须具有相同的类型 无论在初始化还是步进部分，语句都是顺序执行的。 eg: 123for(int i=1,j=i+10;i&lt;5;i++,j=i*2)&#123; System.out.println(\"x\");&#125; 4.5 return void返回值类型的函数内部，编译器会自动添加一个 return； 语句 4.7 臭名昭著的goto goto语句实在源码级上进行跳转。由此带来的问题是：程序的控制流程很难识别，使得程序很难分析 尽管goto仍然是java的保留字，但是语言中并未使用它。 虽然java没有goto，但是利用break，continue这两个关键词，可以在迭代语句中实现源码级跳转，但是也仅限用于迭代语句，这就相当于是精简版的goto 通过精简“goto”的能力，使得程序可读性更高，反而使得语言特性更加有用 利用break，continue实现代码级跳转的具体规则： java中，标签唯一起作用的地方就是刚好在迭代语句之前；在标签和迭代语句之间不能有任何的代码 规则： 1）一般的continue会退回最内层循环的标签位置，并重新进入紧接在那个标签后面的循环 2）带标签的continue会到达标签的位置，并重新进入紧接在那个标签后面的循环 3）一般的break会中断并跳出当前循环 4）带标签的break会中断并跳出标签所指的循环 12345678910111213label1：outer-iteration&#123; inner-iteration&#123; //... break;//(1) //... continue;//(2) //... continue label1;//(3) //... break label1;//(4) &#125;&#125; 4.8 switch swith的选择因子必须是int或char那样的整数值 String类型是不能直接作为选择因子的，可以将其封装成enum作为选择因子","categories":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/categories/ThinkinJava/"}],"tags":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/tags/ThinkinJava/"}]},{"title":"Thinking in Java 第三章 运算符","date":"2017-11-21T11:32:48.000Z","path":"2017/11/21/Thinking-in-Java-第三章-运算符/","text":"第三章 运算符3.7 关系运算符 ==和equals()的区别： ==(!=)：比较的都是对象的引用，不会去比对象真实的值，基本类型一般用该方法进行比较 equals()：默认的行为是比较引用，所以对自定义的类的对象进行equal()比较时仍然比较的是引用；但是java类库中的对象已经重写了该方法，比较的是对象内容 3.8 逻辑运算符 与(&amp;&amp;)、或(||)、非(!)操作只可以应用于布尔值。与C/C++不同的是：不可将一个非布尔值（例如int型的值）作布尔值在逻辑表达式中应用。 eg：int i=10;int j=0;boolean f=i&amp;&j; //wrong 3.9 直接常量 float f4=1e-43f; 编译器通常会将指数作为双精度数(double)处理，所以假如没有这个尾随的f，就会收到一条错误提示，告诉我们必须使用类型转换将double转换成float 3.10 按位操作符 按位与(&amp;)、或(|)、非(~)、异或(^) 将boolean类型作为一种单比特对待时，可以对其执行按位“与”、“或”、“异或”运算，但是不能执行按位“非”（大概是为了与逻辑NOT逻辑混乱）；对于布尔值，按位操作符与逻辑操作符效果相同，只是它们不会“短路”。此外，针对boolean值进行按位运算为我们新增了一个“异或”逻辑操作符，但它并未包括在“逻辑”操作的列表中。 3.11 移位操作符 移位操作符只能用于处理整数 &lt;&lt;:左移操作符，向左按位移动，低位自动补0 右移操作符&gt;&gt;： “有符号数”(&gt;&gt;)：符号为正，高位插0；符号为负，高位插1 “无符号数”(&gt;&gt;&gt;)：无论正负，高位插入0 如果对char、byte、short类型的数值进行移位，那么在移位进行之前，它会被转换为int类型，并且得到的结果也是一个int类型的值，但是返回值会被再次截断 4.二进制 对于原码, 反码, 补码而言, 需要注意以下几点: (1).Java中没有无符号数, 换言之, Java中的数都是有符号的; (2).二进制的最高位是符号位, 0表示正数, 1表示负数; (3).正数的原码, 反码, 补码都一样; (4).负数的反码=它的原码符号位不变, 其他位取反; (5).负数的补码=它的反码+1; (6).0的反码, 补码都是0; (7).在计算机运算的时候, 都是以补码的方式来运算的. 3.13 字符串操作符 + 和 +=为什么Java不支持操作符重载？url: https://www.zhihu.com/question/24013247概括起来：使用+或+=进行字符串连接时，会把非字符串的变量转换成字符串；但是这并不是实现了+运算符的重载，因为在底层的实现上，是利用了StringBuilder加append方法实现的 3.15 类型转换操作符 在java中，类型转换时一种比较安全的操作 窄化转换：可能会丢失信息，因此编译器会强制显式类型转换 扩展转换：不必显式转换 java允许除boolean类型外所有的基本数据类型的相互转换 如果对基本数据类型进行算术运算或按位运算：只要类型比int小（char、byte、short），运算之前，这些值会自动转换成int，最终的生成结果就是int类型； 表达式中最大的数据类型决定了表达式最终结果的数据类型，eg:float*double=double 3.16 java没有sizeof java不需要sizeof()操作符，因为所有数据类型在所有机器中的大小是一样的；C++需要sizeof()是因为要适配不同的机型","categories":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/categories/ThinkinJava/"}],"tags":[{"name":"ThinkinJava","slug":"ThinkinJava","permalink":"http://matlabchina.cn/tags/ThinkinJava/"},{"name":"Java运算符","slug":"Java运算符","permalink":"http://matlabchina.cn/tags/Java运算符/"}]},{"title":"Spring注解@Value取值为NULL的解决方案","date":"2017-11-20T16:02:11.000Z","path":"2017/11/21/Value取值为NULL的解决方案/","text":"在spring mvc架构中，如果希望在程序中直接使用properties中定义的配置值，通常使用一下方式来获取： @Value(&quot;${tag}&quot;) private String tagValue; 但是取值时，有时这个tagvalue为NULL，可能原因有： 使用static或final修饰了tagValue，如下： private static String tagValue; //错误 private final String tagValue; //错误 类没有加上@Component(或者@service等) @Component //遗漏 class TestValue{ @Value(&quot;${tag}&quot;) private String tagValue; } 类被new新建了实例，而没有使用@Autowired @Component class TestValue{ @Value(&quot;${tag}&quot;) private String tagValue; } class Test{ ... TestValue testValue = new TestValue() } 这个testValue中肯定是取不到值的，必须使用@Autowired： class Test{ @AutoWired TestValue testValue }","categories":[{"name":"Spring","slug":"Spring","permalink":"http://matlabchina.cn/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://matlabchina.cn/tags/Spring/"},{"name":"@Annotation","slug":"Annotation","permalink":"http://matlabchina.cn/tags/Annotation/"}]},{"title":"Hello Hexo","date":"2017-11-20T16:02:10.000Z","path":"2017/11/21/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://matlabchina.cn/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://matlabchina.cn/tags/hexo/"}]}]