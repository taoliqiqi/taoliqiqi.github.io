[{"title":"8张图看清 async、await 和 promise 的执行顺序","date":"2018-12-14T01:27:04.000Z","path":"2018/12/14/async/","text":"原文链接 测试一下自己有没有必要看先来一道烂大街的「今日头条」的面试题123456789101112131415161718192021222324252627282930313233343536async function async1() &#123; console.log( 'async1 start' ) await async2() console.log( 'async1 end' )&#125;async function async2() &#123; console.log( 'async2' )&#125;console.log( 'script start' )setTimeout( function () &#123; console.log( 'setTimeout' )&#125;, 0 )async1();new Promise( function ( resolve ) &#123; console.log( 'promise1' ) resolve();&#125; ).then( function () &#123; console.log( 'promise2' )&#125; )console.log( 'script end' )// script start// async1 start// async2// promise1// script end// promise2// async1 end// setTimeout 需要具备的前置知识 promise的使用经验 浏览器端的eventloop 不过如果是对 ES7 的 async 不太熟悉，是没关系的哈，因为这篇文章会详解 async。那么如果不具备这些知识呢，推荐几篇我觉得讲得比较清楚的文章 https://segmentfault.com/a/1190000012806637 这是我之前写的讲解eventloop的文章，我觉得还算清晰，但是没涉及 async。https://segmentfault.com/a/1190000007535316 这是我读过的讲async await最清楚的文章http://es6.ruanyifeng.com/#docs/promise promise就推荐阮一峰老师的ES6吧，不过不熟悉 promise 的应该较少啦。 1.对于async await的理解我推荐的那篇文章，对 async/await 讲得更详细。不过我希望自己能更加精炼的帮你理解它们 这部分，主要会讲解 3 点内容 async 做一件什么事情？ await 在等什么？ await 等到之后，做了一件什么事情？ 补充: async/await 比 promise有哪些优势？（回头补充） 1.1 async 做一件什么事情？ 一句话概括： 带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象 也就是:如果async关键字函数返回的不是promise，会自动用Promise.resolve()包装； 如果async关键字函数显式地返回promise，那就以你返回的promise为准； 这是一个简单的例子，可以看到 async 关键字函数和普通函数的返回值的区别。 1234567891011121314async function fn1()&#123; return 123&#125;function fn2()&#123; return 123&#125;console.log(fn1())console.log(fn2())Promise &#123;&lt;resolved&gt;: 123&#125;// 123 所以你看，async 函数也没啥了不起的，以后看到带有 async 关键字的函数也不用慌张，你就想它无非就是把return值包装了一下，其他就跟普通函数一样。 关于async关键字还有那些要注意的？ 在语义上要理解，async表示函数内部有异步操作 另外注意，一般 await 关键字要在 async 关键字函数的内部，await 写在外面会报错。 1.2 await 在等什么？ 一句话概括： await等的是右侧「表达式」的结果 也就是说， 右侧如果是函数，那么函数的return值就是「表达式的结果」 右侧如果是一个 ‘hello’ 或者什么值，那表达式的结果就是 ‘hello’ 12345678910111213async function async1() &#123; console.log( 'async1 start' ) await async2() console.log( 'async1 end' )&#125;async function async2() &#123; console.log( 'async2' )&#125;async1()console.log( 'script start' ) 这里注意一点，可能大家都知道await会让出线程，阻塞后面的代码，那么上面例子中， ‘async2’ 和 ‘script start’ 谁先打印呢？ 是从左向右执行，一旦碰到await直接跳出, 阻塞async2()的执行？ 还是从右向左，先执行async2后，发现有await关键字，于是让出线程，阻塞代码呢？ 实践的结论是，从右向左的。先打印async2，后打印的script start 之所以提一嘴，是因为我经常看到这样的说法，「一旦遇到await就立刻让出线程，阻塞后面的代码」 这样的说法，会让我误以为，await后面那个函数， async2()也直接被阻塞呢。 1.3 await 等到之后，做了一件什么事情？那么右侧表达式的结果，就是await要等的东西。 等到之后，对于await来说，分2个情况 不是promise对象 是promise对象 如果不是 promise , await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果 如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。 2. 画图一步步看清宏任务、微任务的执行过程我们以开篇的经典面试题为例，分析这个例子中的宏任务和微任务。1234567891011121314151617181920212223242526async function async1() &#123; console.log( 'async1 start' ) await async2() console.log( 'async1 end' )&#125;async function async2() &#123; console.log( 'async2' )&#125;console.log( 'script start' )setTimeout( function () &#123; console.log( 'setTimeout' )&#125;, 0 )async1();new Promise( function ( resolve ) &#123; console.log( 'promise1' ) resolve();&#125; ).then( function () &#123; console.log( 'promise2' )&#125; )console.log( 'script end' ) 先分享一个我个人理解的宏任务和微任务的慨念，在我脑海中宏任务和为微任务如图所示 image 也就是「宏任务」、「微任务」都是队列。 一段代码执行时，会先执行宏任务中的同步代码， 如果执行中遇到setTimeout之类宏任务，那么就把这个setTimeout内部的函数推入「宏任务的队列」中，下一轮宏任务执行时调用。 如果执行中遇到promise.then()之类的微任务，就会推入到「当前宏任务的微任务队列」中，在本轮宏任务的同步代码执行都完成后，依次执行所有的微任务1、2、3 下面就以面试题为例子，分析这段代码的执行顺序. 每次宏任务和微任务发生变化，我都会画一个图来表示他们的变化。 直接打印同步代码 console.log(‘script start’) 首先是2个函数声明，虽然有async关键字，但不是调用我们就不看。然后首先是打印同步代码 console.log(‘script start’) image 将setTimeout放入宏任务队列 默认所包裹的代码，其实可以理解为是第一个宏任务，所以这里是宏任务2 image 调用async1，打印 同步代码 console.log( ‘async1 start’ ) 我们说过看到带有async关键字的函数，不用害怕，它的仅仅是把return值包装成了promise，其他并没有什么不同的地方。所以就很普通的打印 console.log( ‘async1 start’ ) image 分析一下 await async2() 前文提过await，1.它先计算出右侧的结果，2.然后看到await后，中断async函数 先得到await右侧表达式的结果。执行async2()，打印同步代码console.log(‘async2’), 并且return Promise.resolve(undefined) await后，中断async函数，先执行async外的同步代码 目前就直接打印 console.log(‘async2’) image 被阻塞后，要执行async之外的代码。 执行new Promise()，Promise构造函数是直接调用的同步代码，所以 console.log( ‘promise1’ ) image 代码运行到promise.then() 代码运行到promise.then()，发现这个是微任务，所以暂时不打印，只是推入当前宏任务的微任务队列中。 注意：这里只是把promise2推入微任务队列，并没有执行。微任务会在当前宏任务的同步代码执行完毕，才会依次执行 image 打印同步代码 console.log( ‘script end’ ) 没什么好说的。执行完这个同步代码后，「async外的代码」终于走了一遍 下面该回到 await 表达式那里，执行await Promise.resolve(undefined)了。 image 回到async内部，执行await Promise.resolve(undefined) 这部分可能不太好理解，我尽量表达我的想法。 对于 await Promise.resolve(undefined) 如何理解呢？ 根据 MDN 原话我们知道 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await 如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。 在我们这个例子中，就是Promise.resolve(undefined)正常处理完成，并返回其处理结果。那么await async2()就算是执行结束了。 目前这个promise的状态是fulfilled，等其处理结果返回就可以执行await下面的代码了。 那何时能拿到处理结果呢？ 回忆平时我们用promise，调用resolve后，何时能拿到处理结果？是不是需要在then的第一个参数里，才能拿到结果。 （调用resolve时，会把then的参数推入微任务队列，等主线程空闲时，再调用它） 所以这里的 await Promise.resolve() 就类似于 12Promise.resolve(undefined).then((undefined) =&gt; &#123;&#125;) 把then的第一个回调参数 (undefined) =&gt; {} 推入微任务队列。 then执行完，才是await async2()执行结束。 await async2()执行结束，才能继续执行后面的代码。 如图 image 此时当前宏任务1都执行完了，要处理微任务队列里的代码。 微任务队列，先进选出的原则， 执行微任务1，打印promise2 执行微任务2，没什么内容.. 但是微任务2执行后，await async2()语句结束，后面的代码不再被阻塞，所以打印 console.log( ‘async1 end’ ) 宏任务1执行完成后,执行宏任务2 宏任务2的执行比较简单，就是打印 console.log(‘setTimeout’) ==补充在不同浏览器上的测试结果== 谷歌浏览器，目前是版本是「版本 71.0.3578.80（正式版本） （64 位）」 Mac操作系统 image Safari浏览器的测试结果 image 火狐浏览器的测试结果 image","categories":[{"name":"async","slug":"async","permalink":"http://taoliqiqi.github.io/categories/async/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://taoliqiqi.github.io/tags/面试/"}]},{"title":"Javascript数据类型","date":"2018-12-03T01:27:04.000Z","path":"2018/12/03/jsdata1/","text":"1.区分大小写 Html/css不区分大小写，Html.data属性，名字会自动转小写，类似 JQuery.data() 方法 2.变量 var定义 局部变量：不可被删除；变量可被提前；不用var 全局变量（window一个属性）：可被删除（对象的属性可以被删除）；不可提前（属性是无序的） 3.数据类型 基础数据类型 原始数据类型/不可改变数据类型对象 复杂数据类型/可变数据类型、可使用属性、方法 4. typeof 是操作符，返回值都是字符串typeof(null) // object 5.undefined、null、NaN undefined 一个变量已定义，但是没有值 typeof未初始化，未声明变量，会返回该值null 空指针对象 undefined == null //trueNaN 是数值，不等于任何数值 NaN == NaN //false undefinednull相同点都只有一个值，参与判断返回false,不能调用方法 不同点不是关键字是关键字是属性，值叫“未定义”对象，空的未初始化已初始化typeof返回undefinedtypeof返回object转数字结果为NaN转数字结果为0 6.Boolean 对一个变量使用Boolean，相当于使用!!6种数据转Boolean为false：undefined, null, 0, -0, &quot;&quot;, NaN[], {} 转Boolean为true 7.Number 包括常规数字，无穷， NaN对于常规数字，尽量用十进制，少用十六进制，不用八进制十进制 数字范围：1-2^&#123;53&#125; - 2^&#123;53&#125; 八进制 严格模式下无效浮点数 计算机中，所有数字都是二进制，不是所有小数都能用二进制表示。（只能表示小数点后52位）永远不要比较小数，如果一定要比较，乘以10的倍数转成整数再比较 除以0 正常情况下返回Infinity/-Infinity; 0/0 -&gt; NaNIsNaN() 判断传入的值是否可以转为数字 8.数值转换 几种特殊数据转换：Number(undefined) -&gt; NaNNumber(null) -&gt; 0Number(&quot;&quot;) -&gt; 0Number([]) -&gt; 0Number({}) -&gt; NaNNumber() 适用任何类型parseInt() 适用于字符串parseFloat() 适用于字符串在使用parseInt(), parseFloat()，尽量使用“10”做第二个参数，代表传进来的第一个参数是用什么表示的。 9.String 转义字符 长度1；\\u03a3 长度1string() 适用于任何类型 toString()undefined, null没有该方法number.toString(2~16的参数)转为对应进制的数字number,bool,string,object都有该方法 Number(),Boolean(),String()相同点 Number(),Boolean(),String() 都有同名函数，首字母大写 可转换任意数据类型 得到的结果都和自己对应 结果分成两类（对象传到String()里面，转换出带object的字符串 String() new String() 原生类型，一种内建函数 转出object valueOf 适用于Boolean,Number,String,Object 10.Object 各种属性构成的无序集合，由键-值（包括普通数据、对象、方法）对组成 原始数据类型 对象 无属性 有属性 无方法 有方法 不可改变 可改变 比较值 比较引用 对象分类内部对象（17个）：常用对象（8个：bool,string,number,数组,Date,function,object,正则），错误对象，内置对象（Math,Global,Json：可不使用new)数组对象（用得较多的是window,document)自定义对象 基础数据类型转为object123456789101112bool -&gt; object // &#123;'原始值'： true&#125;number -&gt; object // &#123;'原始值' ： 数字&#125;string -&gt; object // &#123; '原始值' ：'abc', 'length'：3, '0': 'a', '1': 'b', '2': 'c'&#125;undefined/null -&gt; object // &#123;&#125; （但是不能使用对象的方法）new Object(undefined) // &#123;&#125;new Object(null) // &#123;&#125; (现在浏览器不报错，但是实际是不能转化) 创建对象的方法 对象直接量 1234var obj = &#123; a: 123, b: \"hello\"&#125; new Object() （括号可省略，不推荐这么使用） create方法（ES5） 属性查询obj.key &lt;=&gt; obj[key] 先计算obj是否undefined或者null，是的话报错 先计算obj是否对象，不是，转对象 是对象后，若是.操作，把.后属性对应的值返回；若是[]操作，先计算括号内内容，转字符串，然后返回字符串的值 找不到值，返回undefined object -&gt; 数字 先valueOf(), 再toString()； object -&gt; 字符串 先toString(), 再valueOf() 1234567[]（转换）-&gt;数字（先valueOf()) -&gt; [](再toString()) -&gt; \"\" (再转数字) -&gt; 0&#123;&#125;（转换）-&gt;数字（先valueOf()) -&gt; &#123;&#125;(再toString()) -&gt; \"[object object]\" (再转数字) -&gt; NaNobject -&gt; bool //全是trueArray -&gt; toString() // 逗号组合项的字符串function -&gt; toString() //源代码日期 -&gt; toString() //日期时间组合字符串valueOf(): 有原始值，返回值；无原始值，返回object本身（Date除外，返回至1970年以来的毫秒数） 11. 表达式 1+1 两个1是表达式， + 是操作符 原始表达式 常量、变量、直接量、关键字 初始化表达式 对象、数组 函数表达式 函数调用表达式 属性访问表达式 . [] new对象创建表达式 12.一元操作符 只能操作一个值的操作符","categories":[{"name":"js","slug":"js","permalink":"http://taoliqiqi.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://taoliqiqi.github.io/tags/js/"}]},{"title":"angular-ZERO","date":"2018-02-18T03:05:08.000Z","path":"2018/02/18/angular-ZERO/","text":"1.Input reference这里引用的是input对象 ，我们如果想传递input的值，可以用usernameRef.value ，然后就可以把 onClick() 方法改成 onClick(usernameRef.value) 12&lt;input #usernameRef type=&quot;text&quot;&gt;&lt;button (click)=&quot;onClick(usernameRef.value)&quot;&gt;Login&lt;/button&gt; 2.Dependency Inject Service如果不使用 DI（依赖性注入) 的时候，我们自然的想法是这样的，在 login.component.ts 中 import 引入 AuthService，在构造中 初始化 service ，在 onClick 中 调用 service 。123456789101112131415161718192021222324252627282930313233import &#123; Component, OnInit &#125; from '@angular/core';//引入AuthServiceimport &#123; AuthService &#125; from '../core/auth.service';@Component(&#123; selector: 'app-login', template: ` &lt;div&gt; &lt;input #usernameRef type=\"text\"&gt; &lt;input #passwordRef type=\"password\"&gt; &lt;button (click)=\"onClick(usernameRef.value, passwordRef.value)\"&gt;Login&lt;/button&gt; &lt;/div&gt; `, styles: []&#125;)export class LoginComponent implements OnInit &#123; //声明成员变量，其类型为AuthService service: AuthService; constructor() &#123; this.service = new AuthService(); &#125; ngOnInit() &#123; &#125; onClick(username, password) &#123; //调用service的方法 console.log('auth result is: ' + this.service.loginWithCredentials(username, password)); &#125;&#125; 这么做呢也可以跑起来，但存在几个问题： 由于实例化是在组件中进行的，意味着我们如果更改service的构造函数的话，组件也需要更改。 如果我们以后需要开发、测试和生产环境配置不同的AuthService，以这种方式实现会非常不方便。 使用依赖注入 使用 import (providers:[AuthService]) 123456789101112131415161718192021222324252627282930import &#123; Component, OnInit &#125; from '@angular/core';import &#123; AuthService &#125; from '../core/auth.service';@Component(&#123; selector: 'app-login', template: ` &lt;div&gt; &lt;input #usernameRef type=\"text\"&gt; &lt;input #passwordRef type=\"password\"&gt; &lt;button (click)=\"onClick(usernameRef.value, passwordRef.value)\"&gt;Login&lt;/button&gt; &lt;/div&gt; `, styles: [], //在providers中配置AuthService providers:[AuthService]&#125;)export class LoginComponent implements OnInit &#123; //在构造函数中将AuthService示例注入到成员变量service中 //而且我们不需要显式声明成员变量service了 constructor(private service: AuthService) &#123; &#125; ngOnInit() &#123; &#125; onClick(username, password) &#123; console.log('auth result is: ' + this.service.loginWithCredentials(username, password)); &#125;&#125; 不import service In app.module.ts 123providers: [ &#123;provide: 'auth', useClass: AuthService&#125; ] In login.component.ts 12constructor(@Inject('auth') private service) &#123; &#125; 3.数据绑定 image 4.建立模拟web服务和异步操作1npm install --save angular-in-memory-web-api 创建src\\app\\todo\\todo-data.ts 123456789101112import &#123; InMemoryDbService &#125; from 'angular-in-memory-web-api';import &#123; Todo &#125; from './todo.model';export class InMemoryTodoDbService implements InMemoryDbService &#123; createDb() &#123; let todos: Todo[] = [ &#123;id: \"f823b191-7799-438d-8d78-fcb1e468fc78\", desc: 'Getting up', completed: true&#125;, &#123;id: \"c316a3bf-b053-71f9-18a3-0073c7ee3b76\", desc: 'Go to school', completed: false&#125; ]; return &#123;todos&#125;; &#125;&#125;","categories":[{"name":"Angular","slug":"Angular","permalink":"http://taoliqiqi.github.io/categories/Angular/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://taoliqiqi.github.io/tags/angular/"}]},{"title":"http-chapter1","date":"2018-02-11T06:27:04.000Z","path":"2018/02/11/http-chapter1/","text":"1.1 使用HTTP协议访问Web image Web浏览器从Web服务器端获取文件资源(resource)，从而显示Web页面。 image 通过发送请求获取服务器资源的Web浏览器等，都可称为客户端(client)。 一些定义 1234HTTP（HyperText Transfer Protocol) 超文本传输协议HTML（HyperText Markup Language) 超文本标记语言WWW（World Wide Web) 万维网URL（Uniform Resource Locator) 统一资源定位符 1.2 TCP/IP协议 定义 12345TCP/IP 是互联网相关的各类协议族的总称。HTTP 属于它内部的一个子集。Protocol:计算机与网络设备相互通信的规则，称为协议。 1.2.1 TCP/IP的分层管理TCP/IP 协议族按层次分别分为以下 4层：应用层、传输层、网络层和数据链路层。 应用层：决定了向用户提供应用服务时通信的活动。FTP（File Transfer Protocol，文件传输协议），DNS（Domain Name System，域名系统），HTTP协议。 传输层：提供处于网络连接中的两台计算机之间的数据传输。TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。 网络层：处理在网络上流动的数据包（网络传输的最小数据单位）。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。 数据链路层：处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。","categories":[{"name":"Http","slug":"Http","permalink":"http://taoliqiqi.github.io/categories/Http/"}],"tags":[{"name":"http","slug":"http","permalink":"http://taoliqiqi.github.io/tags/http/"}]},{"title":"Hello Hexo","date":"2017-11-20T16:02:10.000Z","path":"2017/11/21/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://taoliqiqi.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://taoliqiqi.github.io/tags/hexo/"}]}]